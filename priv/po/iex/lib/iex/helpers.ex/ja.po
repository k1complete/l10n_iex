msgid ""
msgstr ""
"Project-Id-Version: l 10n_iex\n"
"PO-Revision-Date: 2015-09-19 12:58+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.IEx.Helpers Summary
#: lib/iex/helpers.ex:2
msgid ""
"Welcome to Interactive Elixir. You are currently\n"
"seeing the documentation for the module `IEx.Helpers`\n"
"which provides many helpers to make Elixir's shell\n"
"more joyful to work with.\n"
"\n"
"This message was triggered by invoking the helper\n"
"`h()`, usually referred to as `h/0` (since it expects 0\n"
"arguments).\n"
"\n"
"There are many other helpers available:\n"
"\n"
"  * `b/1`           - prints callbacks info and docs for a given module\n"
"  * `c/2`           — compiles a file at the given path\n"
"  * `cd/1`          — changes the current directory\n"
"  * `clear/0`       — clears the screen\n"
"  * `flush/0`       — flushes all messages sent to the shell\n"
"  * `h/0`           — prints this help message\n"
"  * `h/1`           — prints help for the given module, function or macro\n"
"  * `l/1`           — loads the given module's beam code\n"
"  * `ls/0`          — lists the contents of the current directory\n"
"  * `ls/1`          — lists the contents of the specified directory\n"
"  * `pid/3`         — creates a PID with the 3 integer arguments passed\n"
"  * `pwd/0`         — prints the current working directory\n"
"  * `r/1`           — recompiles and reloads the given module's source file\n"
"  * `respawn/0`     — respawns the current shell\n"
"  * `s/1`           — prints spec information\n"
"  * `t/1`           — prints type information\n"
"  * `v/0`           — retrieves the last value from the history\n"
"  * `v/1`           — retrieves the nth value from the history\n"
"  * `import_file/1` — evaluates the given file in the shell's context\n"
"\n"
"Help for functions in this module can be consulted\n"
"directly from the command line, as an example, try:\n"
"\n"
"    h(c/2)\n"
"\n"
"You can also retrieve the documentation for any module\n"
"or function. Try these:\n"
"\n"
"    h(Enum)\n"
"    h(Enum.reverse/1)\n"
"\n"
"To discover all available functions for a module, type the module name\n"
"followed by a dot, then press tab to trigger autocomplete. For example:\n"
"\n"
"    Enum.\n"
"\n"
"To learn more about IEx as a whole, just type `h(IEx)`.\n"
msgstr ""
"インタラクティブElixirへようこそ。あなたは現在Elixirシェルをもっと楽し\n"
"くするために提供された沢山のヘルパーモジュールである`IEx.Helpers`モジュー\n"
"ルのドキュメントを参照しています。\n"
"\n"
"このメッセージは通常`h/0`(これは引数の数が0個ということを示しています)\n"
"として参照されるヘルパー`h()`により起動され、表示されています。\n"
"\n"
"他に沢山のヘルパーが有効です:\n"
"\n"
"  * `b/1`       - 与えられたモジュールのcallback info と docsを表示します\n"
"  * `c/2`       - 与えられたパスのファイルをコンパイルします\n"
"  * `cd/1`      - カレントディレクトリを変更します\n"
"  * `clear/0`   - スクリーンをクリアします\n"
"  * `flush/0`   - シェルへ送信した全メッセージを破棄します\n"
"  * `h/0`       - このヘルプメッセージを表示します\n"
"  * `h/1`       - 与えられたモジュール、関数、マクロのヘルプを表示します\n"
"  * `l/1`       - beamコードをロードして現在のバージョンをパージします\n"
"  * `ls/0`      - カレントディレクトリの内容をリストします\n"
"  * `ls/1`      - 指定されたディレクトリの内容をリストします\n"
"  * `pid/3`     - 渡された3つの整数の引数でPIDを作成します\n"
"  * `pwd/0`     - カレントワーキングディレクトリを表示します\n"
"  * `r/1`       - 与えられたモジュールのソースコードを再コンパイルしてリロードします\n"
"  * `respawn/0` - 現在のシェルを再生成します\n"
"  * `s/1`       - Spec情報を表示します\n"
"  * `t/1`       - 型情報を表示します\n"
"  * `v/0`       - ヒストリの最近の値を取り出します\n"
"  * `v/1`       - ヒストリのn番目の値を取り出します\n"
"  * `import_file/1` - シェルのコンテキストで与えられたファイルを評価します\n"
"\n"
"このモジュールの関数のヘルプはコマンドラインから\n"
"このようにして、直接調べることができる。やってみよう:\n"
"\n"
"    h(c/2)\n"
"\n"
"任意のモジュールあるいは関数のドキュメントも取り出すことがきる。このよ\n"
"うにしてみよう:\n"
"\n"
"    h(Enum)\n"
"    h(Enum.reverse/1)\n"
"\n"
"モジュールで全ての有効な関数を見付けるためには、モジュール名の後ろで\n"
"ドットをタイプして、それからタブを押すことで、オートコンプリートが\n"
"起動されます。例えば:\n"
"\n"
"    Enum.\n"
"\n"
"IEx全体についてもっと学ぶためには、`h(IEx)`とタイプしよう。\n"

#. TRANSLATORS: def IEx.Helpers.r(module)
#: lib/iex/helpers.ex:291
msgid ""
"Recompiles and reloads the given `module`.\n"
"\n"
"Please note that all the modules defined in the same\n"
"file as `module` are recompiled and reloaded.\n"
"\n"
"## In-memory reloading\n"
"\n"
"When we reload the module in IEx, we recompile the module source code,\n"
"updating its contents in memory. The original `.beam` file in disk,\n"
"probably the one where the first definition of the module came from,\n"
"does not change at all.\n"
"\n"
"Since typespecs and docs are loaded from the .beam file (they are not\n"
"loaded in memory with the module because there is no need for them to\n"
"be in memory), they are not reloaded when you reload the module.\n"
msgstr ""
"`module`をリコンパイル、リロードします。\n"
"\n"
"`module`と同じファイルに定義された全てのモジュールも\n"
"リコンパイル、リロードされます。\n"
"\n"
"## In-memory reloading\n"
"\n"
"IExでモジュールをリロードする時、モジュールソースコードを\n"
"リコンパイルし、メモリの内容を更新します。\n"
"モジュールの最初の定義であるディスクのオリジナルの`.beam`ファイル\n"
"は全く変更されません。\n"
"\n"
"typespecsとdocsが.beamファイルからロードされたときから(\n"
"必要がないため、それらはメモりにロードされません)、\n"
"モジュールをリロードしても、それらはリロードされません。\n"

#. TRANSLATORS: def IEx.Helpers.ls(path \\ ".")
#: lib/iex/helpers.ex:390
msgid ""
"Produces a simple list of a directory's contents.\n"
"\n"
"If `path` points to a file, prints its full path.\n"
msgstr ""
"シンプルなディレクトリの内容のリストを提供します。\n"
"\n"
"もし`path`がファイルを指していたら、そのフルパスを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.v(n \\ -1)
#: lib/iex/helpers.ex:281
msgid ""
"Retrieves the nth expression's value from the history.\n"
"\n"
"Use negative values to lookup expression values relative to the current "
"one.\n"
"For instance, v(-1) returns the result of the last evaluated expression.\n"
msgstr ""
"ヒストリからn番目の式を取り出します。\n"
"\n"
"現在の地点からの相対的に指定するためには負の値を使ってください。\n"
"例えば、v(-1)は最後に評価された式を返します。\n"

#. TRANSLATORS: def IEx.Helpers.respawn()
#: lib/iex/helpers.ex:455
msgid ""
"Respawns the current shell by starting a new shell process.\n"
"\n"
"Returns `true` if it worked.\n"
msgstr ""
"新しいスコープとプロセスを開始することで現在のシェルを再生成します。\n"
"\n"
"成功すると`true`を返します。\n"

#. TRANSLATORS: defmacro IEx.Helpers.t(term)
#: lib/iex/helpers.ex:214
msgid ""
"Prints the types for the given module or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    t(Enum)\n"
"    t(Enum.t/0)\n"
"    t(Enum.t)\n"
msgstr ""
"与えられたモジュールか与えられたfunction/arityペアのtypeを表示\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    t(Enum)\n"
"    t(Enum.t/0)\n"
"    t(Enum.t)\n"

#. TRANSLATORS: defmacro IEx.Helpers.s(term)
#: lib/iex/helpers.ex:242
msgid ""
"Prints the specs for the given module or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    s(Enum)\n"
"    s(Enum.all?)\n"
"    s(Enum.all?/2)\n"
"    s(is_atom)\n"
"    s(is_atom/1)\n"
"\n"
msgstr ""
"与えられたモジュールか与えられたfunction/arityペアのspecを表示\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    s(Enum)\n"
"    s(Enum.all?)\n"
"    s(Enum.all?/2)\n"
"    s(is_atom)\n"
"    s(is_atom/1)\n"
"\n"

#. TRANSLATORS: defmacro IEx.Helpers.h(term)
#: lib/iex/helpers.ex:126
msgid ""
"Prints the documentation for the given module\n"
"or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    h(Enum)\n"
"    #=> Prints documentation for Enum\n"
"\n"
"It also accepts functions in the format `fun/arity`\n"
"and `module.fun/arity`, for example:\n"
"\n"
"    h receive/1\n"
"    h Enum.all?/2\n"
"    h Enum.all?\n"
"\n"
msgstr ""
"与えられたモジュールまたは関数/アリティペアのドキュメントを\n"
"表示します。\n"
"\n"
"## 例\n"
"\n"
"    h(Enum)\n"
"    #=> Prints documentation for Enum\n"
"\n"
"関数の書式としては、`fun/arity`または`module.fun/arity`の何れのフォーマッ\n"
"トも受け入れます。\n"
"例えば: \n"
"\n"
"    h receive/1\n"
"    h Enum.all?/2\n"
"    h Enum.all?\n"
"\n"

#. TRANSLATORS: defmacro IEx.Helpers.b(term)
#: lib/iex/helpers.ex:182
msgid ""
"Prints the documentation for the given callback function.\n"
"\n"
"It also accepts single module argument to list\n"
"all available behaviour callbacks.\n"
"\n"
"## Examples\n"
"\n"
"    b(Mix.Task.run/1)\n"
"    b(Mix.Task.run)\n"
"    b(Dict)\n"
"\n"
msgstr ""
"与えられたコールバック関数のドキュメントを表示します。\n"
"\n"
"有効な全てのbehaviourコールバックをリストするためには、\n"
"単一のモジュール引数で呼出します。\n"
"\n"
"## 例\n"
"\n"
"    b(Mix.Task.run/1)\n"
"    b(Mix.Task.run)\n"
"    b(Dict)\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.h()
#: lib/iex/helpers.ex:118
msgid "Prints the documentation for `IEx.Helpers`.\n"
msgstr "`IEx.Helpers`のドキュメントを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.pwd()
#: lib/iex/helpers.ex:372
msgid "Prints the current working directory.\n"
msgstr "現在の作業ディレクトリを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.l(module)
#: lib/iex/helpers.ex:333
msgid ""
"Loads the given module's beam code (and ensures any previous\n"
"old version was properly purged before).\n"
"\n"
"This function is useful when you know the bytecode for module\n"
"has been updated in the filesystem and you want to tell the VM\n"
"to load it.\n"
msgstr ""
"与えられたモジュールのbeamコード(と以前の\n"
"古いバージョンはその前に正しくパージされることを保証します)。\n"
"\n"
"この関数は、ファイルシステムでモジュールのバイトコードが\n"
"更新されたことを知っていて、VMにロードするように教えたい\n"
"時に便利です。\n"

#. TRANSLATORS: def IEx.Helpers.flush()
#: lib/iex/helpers.ex:346
msgid "Flushes all messages sent to the shell and prints them out.\n"
msgstr "シェルへ送られた全てのメッセージを破棄し、それらを表示します。\n"

#. TRANSLATORS: defmacro IEx.Helpers.import_file(path, opts \\ [])
#: lib/iex/helpers.ex:467
msgid ""
"Evaluates the contents of the file at `path` as if it were directly typed "
"into\n"
"the shell.\n"
"\n"
"`path` has to be a literal string. `path` is automatically expanded via\n"
"`Path.expand/1`.\n"
"\n"
"## Non-existent files\n"
"\n"
"By default, `import_file/1` fails when the given file does not exist. "
"However,\n"
"since this macro is expanded at compile-time, it's not possible to\n"
"conditionally import a file since the macro is always expanded:\n"
"\n"
"    # This raises a File.Error if ~/.iex.exs doesn't exist.\n"
"    if (\"~/.iex.exs\" |> Path.expand |> File.exists?) do\n"
"      import_file \"~/.iex.exs\"\n"
"    end\n"
"\n"
"This is why an `:optional` option can be passed to `import_file/1`. The\n"
"default value of this option is `false`, meaning that an exception will be\n"
"raised if the given file is missing. If `:optional` is set to `true`, "
"missing\n"
"files will be ignored and `import_file/1` will just compile to `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # in the shell\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"
"    iex(3)> import_file \"nonexisting.file.ex\", optional: true\n"
"    nil\n"
"\n"
msgstr ""
"`path`のファイルの内容を、シェルからダイレクトに\n"
"タイプされたかのように評価します。\n"
"\n"
"`path`はリテラル文字列でなければなりません。`path`は`Path.expand/1`で\n"
"自動的に展開されます。\n"
"\n"
"## Non-existent files\n"
"\n"
"デフォルとで、`import_file`は与えられたファイルが存在しないと\n"
"失敗します。しかしながら、このマクロはコンパイル時に展開されるので、\n"
"以下のコードは常にマクロ展開されるため、条件付きで\n"
"ファイルをインポートすることは出来ません:\n"
"\n"
"    # This raises a File.Error if ~/.iex.exs doesn't exist.\n"
"    if (\"~/.iex.exs\" |> Path.expand |> File.exists?) do\n"
"      import_file \"~/.iex.exs\"\n"
"    end\n"
"\n"
"これが`import_file/1`に`:optional`オプションを渡す理由です。\n"
"このオプションのデフォルトは`false`で、与えられたファイルがないなら\n"
"例外を上げることを意味しています。`:optional`を`true`にセットすると、\n"
"存在品いファイルは無視され、`import_file/1`は`nil`にコンパイルされます。\n"
"\n"
"## 例\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # in the shell\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"
"    iex(3)> import_file \"nonexisting.file.ex\", optional: true\n"
"    nil\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.pid(x, y, z)
#: lib/iex/helpers.ex:534
msgid ""
"Creates a PID with 3 non negative integers passed as arguments \n"
"to the function.\n"
"\n"
"## Examples\n"
"    iex> pid(0, 21, 32)\n"
"    #PID<0.21.32>\n"
"    iex> pid(0, 64, 2048)\n"
"    #PID<0.64.2048>\n"
msgstr ""
"この関数へ引数として渡された3つの非負整数からPIDを作成します。\n"
"\n"
"## 例\n"
"    iex> pid(0, 21, 32)\n"
"    #PID<0.21.32>\n"
"    iex> pid(0, 64, 2048)\n"
"    #PID<0.64.2048>\n"

#. TRANSLATORS: def IEx.Helpers.c(files, path \\ ".")
#: lib/iex/helpers.ex:55
msgid ""
"Compiles the given files.\n"
"\n"
"It expects a list of files to compile and an optional path to write\n"
"the compiled code to (defaults to the current directory). When compiling\n"
"one file, there is no need to wrap it in a list.\n"
"\n"
"It returns the name of the compiled modules.\n"
"\n"
"If you want to recompile an existing module, check `r/1` instead.\n"
"\n"
"## Examples\n"
"\n"
"    c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    #=> [Foo, Bar]\n"
"\n"
"    c \"baz.ex\"\n"
"    #=> [Baz]\n"
msgstr ""
"与えられた複数のファイルをコンパイルします。\n"
"\n"
"コンパイルするファイルのリストを指定します。\n"
"オプションでコンパイルされたコードを書き出すパスを指定します\n"
"(デフォルトはカレントディレクトリです)。\n"
"一つのファイルをコンパイルする時にリストにする必要はありません。\n"
"\n"
"コンパイルされたモジュールの名前を返します。\n"
"\n"
"もし既存のモジュールをリコンパイルしたいなら、代わりに`r/1`を\n"
"チェックしてみてください。\n"
"\n"
"## 例\n"
"\n"
"    c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    #=> [Foo,Bar]\n"
"\n"
"    c \"baz.ex\"\n"
"    #=> [Baz]\n"

#. TRANSLATORS: def IEx.Helpers.clear()
#: lib/iex/helpers.ex:102
msgid ""
"Clears the console screen.\n"
"\n"
"This function only works if ANSI escape codes are enabled\n"
"on the shell, which means this function is by default\n"
"unavailable on Windows machines.\n"
msgstr ""
"コンソールスクリーンをクリアします。\n"
"\n"
"この関数はANSIエスケープコードが有効なシェルでのみ動作します。\n"
"これはデフォルトではWindowsでは利用できないことを意味します。\n"

#. TRANSLATORS: def IEx.Helpers.cd(directory)
#: lib/iex/helpers.ex:379
msgid "Changes the current working directory to the given path.\n"
msgstr "与えられたパスへカレントディレクトリを変更します。\n"
