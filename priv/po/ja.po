msgid ""
msgstr ""
"Project-Id-Version: l 10n_iex\n"
"PO-Revision-Date: 2016-01-03 10:21+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: lib/l10n_iex.ex:5
msgid "OK"
msgstr "OK"

#~ msgid "Returns registered `after_spawn` callbacks.\n"
#~ msgstr "登録された`after_spawn`コールバックを返します。\n"

#~ msgid ""
#~ "Registers a function to be invoked after the IEx process is spawned.\n"
#~ msgstr "IExプロセスが生成された後に起動される関数を登録します。\n"

#~ msgid ""
#~ "Pries into the process environment.\n"
#~ "\n"
#~ "This is useful for debugging a particular chunk of code\n"
#~ "and inspect the state of a particular process. The process\n"
#~ "is temporarily changed to trap exits (i.e. the process flag\n"
#~ "`:trap_exit` is set to true) and has the `group_leader` changed\n"
#~ "to support ANSI escape codes. Those values are reverted by\n"
#~ "calling `respawn`, which starts a new IEx shell, freeing up\n"
#~ "the pried one.\n"
#~ "\n"
#~ "When a process is pried, all code runs inside IEx and, as\n"
#~ "such, it is evaluated and cannot access private functions\n"
#~ "of the module being pried. Module functions still need to be\n"
#~ "accessed via `Mod.fun(args)`.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "Let's suppose you want to investigate what is happening\n"
#~ "with some particular function. By invoking `IEx.pry` from\n"
#~ "the function, IEx will allow you to access its binding\n"
#~ "(variables), verify its lexical information and access\n"
#~ "the process information. Let's see an example:\n"
#~ "\n"
#~ "    import Enum, only: [map: 2]\n"
#~ "    require IEx\n"
#~ "\n"
#~ "    defmodule Adder do\n"
#~ "      def add(a, b) do\n"
#~ "        c = a + b\n"
#~ "        IEx.pry\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "When invoking `Adder.add(1, 2)`, you will receive a message in\n"
#~ "your shell to pry the given environment. By allowing it,\n"
#~ "the shell will be reset and you gain access to all variables\n"
#~ "and the lexical scope from above:\n"
#~ "\n"
#~ "    pry(1)> map([a,b,c], &IO.inspect(&1))\n"
#~ "    1\n"
#~ "    2\n"
#~ "    3\n"
#~ "\n"
#~ "Keep in mind that `IEx.pry` runs in the caller process,\n"
#~ "blocking the caller during the evaluation cycle. The caller\n"
#~ "process can be freed by calling `respawn`, which starts a\n"
#~ "new IEx evaluation cycle, letting this one go:\n"
#~ "\n"
#~ "    pry(2)> respawn\n"
#~ "    true\n"
#~ "\n"
#~ "    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
#~ "\n"
#~ "Setting variables or importing modules in IEx does not\n"
#~ "affect the caller the environment (hence it is called `pry`).\n"
#~ msgstr ""
#~ "プロセス環境を覗き見します。\n"
#~ "\n"
#~ "これは特定のコードの塊のデバッグと特定のプロセスの状態を\n"
#~ "調べるのに役に立ちます。\n"
#~ "\n"
#~ "プロセスは一時的に`trap exits`に変更され(即ち、プロセスフラグ\n"
#~ "`:trap_exit`がtrueにセットされます)、`group_leader`がANSIエスケープコー\n"
#~ "ドをサポートするために変更されます。\n"
#~ "これらの値は`respawn`を呼ぶことで戻され、新しいIExシェルを始め、\n"
#~ "覗き見していたものを解放します。\n"
#~ "\n"
#~ "プロセスが覗き見されるとき、全てのコードはIExの中で動作します。そして覗\n"
#~ "き見しているモジュールのプライベートな関数にアクセスしたり、評価したり\n"
#~ "出来ません。モジュール関数は、まだ`Mod.fun(args)`でアクセスされる必要が\n"
#~ "あります。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "若干の特定の関数に何が起っているかを調査したいと仮定します。\n"
#~ "IEx.pryを起動することにより、IExはあなたに変数のバインディングへの\n"
#~ "アクセスやレキシカル情報の確認、プロセス情報へのアクセスを\n"
#~ "許可するようになります。例を見てみましょう:\n"
#~ "\n"
#~ "    import Enum, only: [map: 2]\n"
#~ "    require IEx\n"
#~ "\n"
#~ "    defmodule Adder do\n"
#~ "      def add(a, b) do\n"
#~ "        c = a + b\n"
#~ "        IEx.pry\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "`Adder.add(1, 2)`が起動されると、あなたのシェルに与えられた環境を覗くた\n"
#~ "めのメッセージを受信します。これをあなたが許可することで、IEx.pryが呼び\n"
#~ "出された時点でのレキシカルスコープと全ての変数へのアクセスが出来るよう\n"
#~ "になります。\n"
#~ "\n"
#~ "    pry(1)> map([a,b,c], &IO.inspect(&1))\n"
#~ "    1\n"
#~ "    2\n"
#~ "    3\n"
#~ "\n"
#~ "\n"
#~ "評価サイクルの間ブロックされている呼び出し側プロセスの`IEx.pry`は動作中\n"
#~ "であることに注意してください、呼び出し側プロセスは新しいIEx評価サイクル\n"
#~ "を開始させる`respawn`の呼出により解放されます。これをやってみましょう:\n"
#~ "\n"
#~ "    pry(2)> respawn\n"
#~ "    true\n"
#~ "\n"
#~ "    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
#~ "\n"
#~ "IExでの変数の設定やモジュールのインポートは呼び出し側環境へ\n"
#~ "影響を与えません(それ故、それは`pry`(「覗き見」)と呼ばれています)。\n"

#~ msgid ""
#~ "Locates and loads an .iex.exs file from one of predefined locations.\n"
#~ "Returns the new config.\n"
#~ msgstr ""
#~ "予め定義された場所の一つから .iex.exs ファイルの場所を指定してロードしま"
#~ "す。\n"
#~ "新しいコンフィグを返します。\n"

#~ msgid ""
#~ "Recompiles and reloads the specified module's source file.\n"
#~ "\n"
#~ "Please note that all the modules defined in the same file as `module`\n"
#~ "are recompiled and reloaded.\n"
#~ msgstr ""
#~ "指定されたモジュールのソースコードを再コンパイルして再ロードします。\n"
#~ "\n"
#~ "`module`と同じファイルで定義された全てのモジュールが再コンパイル、リロー"
#~ "ド\n"
#~ "されることに注意してください。\n"

#~ msgid ""
#~ "Provides one helper function that is injected into connecting\n"
#~ "remote nodes to properly handle autocompletion.\n"
#~ msgstr ""
#~ "リモートノードへ接続したときに、きちんと自動補間を取り扱うための\n"
#~ "一つのヘルパー関数を提供します。\n"

#~ msgid ""
#~ "Produces a simple list of a directory's contents.\n"
#~ "If `path` points to a file, prints its full path.\n"
#~ msgstr ""
#~ "シンプルなディレクトリの内容のリストを提供します。\n"
#~ "もし`path`がファイルを指していたら、そのフルパスを表示します。\n"

#~ msgid ""
#~ "Starts IEx by executing a given callback and spawning\n"
#~ "the server only after the callback is done.\n"
#~ "\n"
#~ "The server responsibilities include:\n"
#~ "\n"
#~ "  * reading input\n"
#~ "  * sending messages to the evaluator\n"
#~ "  * handling takeover process of the evaluator\n"
#~ "\n"
#~ "If there is any takeover during the callback execution\n"
#~ "we spawn a new server for it without waiting for its\n"
#~ "conclusion.\n"
#~ msgstr ""
#~ "IExの開始時に、与えられたコールバックの実行と、コールバックが実行終了後\n"
#~ "にのみサーバの生成をします。\n"
#~ "\n"
#~ "サーバは以下に責任をもちます:\n"
#~ "\n"
#~ "  * 入力の読み込み\n"
#~ "  * 評価器へのメッセージ送信\n"
#~ "  * 評価器のプロセスのテイクオーバーのハンドリング\n"
#~ "\n"
#~ "もしコールバック実行中にテイクオーバーがあったら、その結果を待つことな\n"
#~ "く新しいサーバを生成します。\n"

#~ msgid ""
#~ "When given a module, prints specifications (or simply specs) for all the\n"
#~ "types defined in it.\n"
#~ "\n"
#~ "When given a particular type name, prints its spec.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    t(Enum)\n"
#~ "    t(Enum.t/0)\n"
#~ "    t(Enum.t)\n"
#~ msgstr ""
#~ "モジュールが与えらえると、そこで定義された全ての型の仕様(または\n"
#~ "spec)を表示します。\n"
#~ "\n"
#~ "明示的に型の名前が与えられると、そのspecが表示されます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    t(Enum)\n"
#~ "    t(Enum.t/0)\n"
#~ "    t(Enum.t)\n"

#~ msgid ""
#~ "Similar to `t/1`, only for specs.\n"
#~ "\n"
#~ "When given a module, prints the list of all specs defined in the module.\n"
#~ "\n"
#~ "When given a particular spec name (with optional arity), prints its "
#~ "spec.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    s(Enum)\n"
#~ "    s(Enum.all?)\n"
#~ "    s(Enum.all?/2)\n"
#~ "    s(is_atom)\n"
#~ "    s(is_atom/1)\n"
#~ "\n"
#~ msgstr ""
#~ "`t/1`と似ていますが、spec用です。\n"
#~ "\n"
#~ "モジュールを与えるとモジュールで定義された全てのspecのリストを表示しま"
#~ "す。\n"
#~ "\n"
#~ "明示的にspec名を指定すると(アリティはオプションです)、そのspecを表示しま"
#~ "す。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    s(Enum)\n"
#~ "    s(Enum.all?)\n"
#~ "    s(Enum.all?/2)\n"
#~ "    s(is_atom)\n"
#~ "    s(is_atom/1)\n"
#~ "\n"

#~ msgid "Returns `true` if IEx was started.\n"
#~ msgstr "もしIExが開始されていたら`true`を返します。\n"

#~ msgid ""
#~ "Returns `string` escaped using the specified `color`.\n"
#~ "\n"
#~ "ANSI escapes in `string` are not processed in any way.\n"
#~ msgstr ""
#~ "指定された`color`を使ってエスケープされた`string`を返します。\n"
#~ "\n"
#~ "`string`の中のANSIエスケープはどのようにも処理されません。\n"
#~ "(`color`はColorsでリストされているスタイルを表すアトムです)\n"

#~ msgid "Returns IEx configuration.\n"
#~ msgstr "IEx設定を返します。\n"

#~ msgid ""
#~ "Retrieves the nth expression's value from the history.\n"
#~ "\n"
#~ "Use negative values to lookup expression values relative to the current "
#~ "one.\n"
#~ "For instance, v(-1) returns the result of the last evaluated expression.\n"
#~ msgstr ""
#~ "ヒストリからn番目の式を取り出します。\n"
#~ "\n"
#~ "現在の地点からの相対的に指定するためには負の値を使ってください。\n"
#~ "例えば、v(-1)は最後に評価された式を返します。\n"

#~ msgid ""
#~ "Respawns the current shell by starting a new\n"
#~ "process and a new scope. Returns true if it worked.\n"
#~ msgstr ""
#~ "新しいスコープとプロセスを開始することで現在のシェルを再生成します。\n"
#~ "成功するとtrueを返します。\n"

#~ msgid ""
#~ "Removes all entries from the history and forces a garbage collection "
#~ "cycle.\n"
#~ msgstr ""
#~ "ヒストリから全てのエントリを削除して、ガベージコレクションサイクルを\n"
#~ "強制します。\n"

#~ msgid ""
#~ "Requests to take over the given shell from the\n"
#~ "current process.\n"
#~ msgstr ""
#~ "現在のプロセスから与えられたシェルへのテイクオーバーを要求します。\n"

#~ msgid ""
#~ "Prints the history of expressions evaluated during the session along "
#~ "with\n"
#~ "their results.\n"
#~ msgstr "セッションの間に評価された式の履歴をその結果とともに表示します。\n"

#~ msgid ""
#~ "Prints the documentation for the given module\n"
#~ "or for the given function/arity pair.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    h(Enum)\n"
#~ "    #=> Prints documentation for Enum\n"
#~ "\n"
#~ "It also accepts functions in the format `fun/arity`\n"
#~ "and `module.fun/arity`, for example:\n"
#~ "\n"
#~ "    h receive/1\n"
#~ "    h Enum.all?/2\n"
#~ "    h Enum.all?\n"
#~ "\n"
#~ msgstr ""
#~ "与えられたモジュールまたは関数/アリティペアのドキュメントを\n"
#~ "表示します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    h(Enum)\n"
#~ "    #=> Prints documentation for Enum\n"
#~ "\n"
#~ "関数の書式としては、`fun/arity`または`module.fun/arity`の何れのフォー"
#~ "マッ\n"
#~ "トも受け入れます。\n"
#~ "例えば: \n"
#~ "\n"
#~ "    h receive/1\n"
#~ "    h Enum.all?/2\n"
#~ "    h Enum.all?\n"
#~ "\n"

#~ msgid "Prints the documentation for `IEx.Helpers`.\n"
#~ msgstr "`IEx.Helpers`のドキュメントを表示します。\n"

#~ msgid "Prints the current working directory.\n"
#~ msgstr "現在の作業ディレクトリを表示します。\n"

#~ msgid ""
#~ "Load the given module's beam code (and ensures any previous\n"
#~ "old version was properly purged before).\n"
#~ msgstr ""
#~ "与えられたモジュールのbeamコードをロードします(そしてその前に\n"
#~ "以前の古いバージョンはパージされます)。\n"

#~ msgid ""
#~ "Initializes IEx process variables. All history\n"
#~ "information is kept in the process dictionary.\n"
#~ msgstr ""
#~ "IExプロセス変数を初期化します。全てのヒストリ情報は\n"
#~ "プロセス辞書にあり、保持されます。\n"

#~ msgid "Gets the options used for inspecting.\n"
#~ msgstr "インスペクトに使うオプションを取得します。\n"

#~ msgid ""
#~ "In order to work properly, IEx needs to be set as the\n"
#~ "proper `-user` when starting the Erlang VM and we do so\n"
#~ "by pointing exactly to this function.\n"
#~ "\n"
#~ "If possible, Elixir will start a tty (smart terminal)\n"
#~ "which makes all control commands available in tty\n"
#~ "available to the developer.\n"
#~ "\n"
#~ "In case `tty` is not available (for example, Windows),\n"
#~ "a dumb terminal version is started instead.\n"
#~ msgstr ""
#~ "きちんと動くために、Erlang VMがスタートするときに\n"
#~ "IExは適切な`-user`を設定する必要があります。\n"
#~ "この関数で正にそれをします。\n"
#~ "\n"
#~ "可能であれば、Elixirは開発者がttyで利用できる\n"
#~ "すべての制御コマンドを持つ tty(スマート端末)を起動します。\n"
#~ "\n"
#~ "`tty`が利用できない場合(たとえば、Windows)、ダム端末バージョンが\n"
#~ "替わりに起動されます。\n"

#~ msgid ""
#~ "Gets the nth item from the history.\n"
#~ "\n"
#~ "If `n` < 0, the count starts from the most recent item and goes back in "
#~ "time.\n"
#~ msgstr ""
#~ "ヒストリからn番目の項目を取得します。\n"
#~ "\n"
#~ "もし`n` < 0なら、もっとも最近のアイテムから後ろ向きに数えます。\n"

#~ msgid "Print types in module.\n"
#~ msgstr "モジュールのタイプを表示します。\n"

#~ msgid "Print type in module with given arity.\n"
#~ msgstr "与えられたアリティのモジュールのタイプを表示します。\n"

#~ msgid "Print the given type in module with any arity.\n"
#~ msgstr "与えられたモジュールの任意のアリティのタイプを表示します。\n"

#~ msgid "Print specs for given module.\n"
#~ msgstr "与えられたモジュールのスペックを表示します。\n"

#~ msgid "Print specs for given module and function.\n"
#~ msgstr "与えられたモジュールと関数のスペックを表示します。\n"

#~ msgid "Print spec in given module, with arity.\n"
#~ msgstr "与えられたモジュールとアリティの関数のスペックを表示します。\n"

#~ msgid "Finds where the current IEx server is located.\n"
#~ msgstr "現在のIExサーバが置かれた場所を見付けます。\n"

#~ msgid ""
#~ "Gets the IEx width for printing.\n"
#~ "\n"
#~ "Used by helpers and it has a maximum cap of 80 chars.\n"
#~ msgstr ""
#~ "IExの表示の幅を取得します\n"
#~ "\n"
#~ "ヘルパーにより使用され、最大80文字となります。\n"

#~ msgid "Flushes all messages sent to the shell and prints them out.\n"
#~ msgstr "シェルへ送られた全てのメッセージを破棄し、それらを表示します。\n"

#~ msgid ""
#~ "Expects a list of files to compile and a path\n"
#~ "to write their object code to. It returns the name\n"
#~ "of the compiled modules.\n"
#~ "\n"
#~ "When compiling one file, there is no need to wrap it in a list.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
#~ "    #=> [Foo,Bar]\n"
#~ "\n"
#~ "    c \"baz.ex\"\n"
#~ "    #=> [Baz]\n"
#~ msgstr ""
#~ "コンパイルするファイルのリストとオブジェクトコードを\n"
#~ "書き出すパスを指定します。コンパイルされたモジュールの名前を\n"
#~ "返します。\n"
#~ "\n"
#~ "一つのファイルをコンパイルする時にリストにする必要はありません\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
#~ "    #=> [Foo,Bar]\n"
#~ "\n"
#~ "    c \"baz.ex\"\n"
#~ "    #=> [Baz]\n"

#~ msgid ""
#~ "Evaluates the contents of the file at `path` as if it were directly typed "
#~ "into\n"
#~ "the shell. `path` has to be a literal binary.\n"
#~ "\n"
#~ "A leading `~` in `path` is automatically expanded.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    # ~/file.exs\n"
#~ "    value = 13\n"
#~ "\n"
#~ "    # in the shell\n"
#~ "    iex(1)> import_file \"~/file.exs\"\n"
#~ "    13\n"
#~ "    iex(2)> value\n"
#~ "    13\n"
#~ msgstr ""
#~ "それが直接シェルでタイプされたかのように`path`のファイルの内容を評価しま"
#~ "す。\n"
#~ "`path`はリテラルバイナリでなくてはなりません。\n"
#~ "\n"
#~ "`path`の先頭の`~`は自動的に展開されます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    # ~/file.exs\n"
#~ "    value = 13\n"
#~ "\n"
#~ "    # in the shell\n"
#~ "    iex(1)> import_file \"~/file.exs\"\n"
#~ "    13\n"
#~ "    iex(2)> value\n"
#~ "    13\n"

#~ msgid ""
#~ "Eval loop for an IEx session. Its responsibilities include:\n"
#~ "\n"
#~ "  * loading of .iex files\n"
#~ "  * evaluating code\n"
#~ "  * trapping exceptions in the code being evaluated\n"
#~ "  * keeping expression history\n"
#~ "\n"
#~ msgstr ""
#~ "IExセッションの評価ループです。以下を行います:\n"
#~ "\n"
#~ "  * .iex ファイルのロード\n"
#~ "  * コードの評価\n"
#~ "  * 評価されているコードの例外をトラップすること\n"
#~ "  * ヒストリの保持\n"
#~ "\n"

#~ msgid ""
#~ "Enumerates over all items in the history starting from the oldest one "
#~ "and\n"
#~ "applies `fun` to each one in turn.\n"
#~ msgstr ""
#~ "もっとも古いものからスタートして全てのヒストリアイテムを列挙して、\n"
#~ "それぞれに`fun`を適用します。\n"

#~ msgid ""
#~ "Configures IEx.\n"
#~ "\n"
#~ "The supported options are: `:colors`, `:inspect`,\n"
#~ "`:default_prompt`, `:alive_prompt` and `:history_size`.\n"
#~ "\n"
#~ "## Colors\n"
#~ "\n"
#~ "A keyword list that encapsulates all color settings used by the\n"
#~ "shell. See documentation for the `IO.ANSI` module for the list of\n"
#~ "supported colors and attributes.\n"
#~ "\n"
#~ "The value is a keyword list. List of supported keys:\n"
#~ "\n"
#~ "  * `:enabled`      - boolean value that allows for switching the "
#~ "coloring on and off\n"
#~ "  * `:eval_result`  - color for an expression's resulting value\n"
#~ "  * `:eval_info`    - … various informational messages\n"
#~ "  * `:eval_error`   - … error messages\n"
#~ "  * `:stack_app`    - … the app in stack traces\n"
#~ "  * `:stack_info`   - … the remaining info in stacktraces\n"
#~ "  * `:ls_directory` - … for directory entries (ls helper)\n"
#~ "  * `:ls_device`    - … device entries (ls helper)\n"
#~ "\n"
#~ "When printing documentation, IEx will convert the markdown\n"
#~ "documentation to ANSI as well. Those can be configured via:\n"
#~ "\n"
#~ "  * `:doc_code`        — the attributes for code blocks (cyan, bright)\n"
#~ "  * `:doc_inline_code` - inline code (cyan)\n"
#~ "  * `:doc_headings`    - h1 and h2 (yellow, bright)\n"
#~ "  * `:doc_title`       — the overall heading for the output (reverse,"
#~ "yellow,bright)\n"
#~ "  * `:doc_bold`        - (bright)\n"
#~ "  * `:doc_underline`   - (underline)\n"
#~ "\n"
#~ "## Inspect\n"
#~ "\n"
#~ "A keyword list containing inspect options used by the shell\n"
#~ "when printing results of expression evaluation. Default to\n"
#~ "pretty formatting with a limit of 50 entries.\n"
#~ "\n"
#~ "See `Inspect.Opts` for the full list of options.\n"
#~ "\n"
#~ "## History size\n"
#~ "\n"
#~ "Number of expressions and their results to keep in the history.\n"
#~ "The value is an integer. When it is negative, the history is unlimited.\n"
#~ "\n"
#~ "## Prompt\n"
#~ "\n"
#~ "This is an option determining the prompt displayed to the user\n"
#~ "when awaiting input.\n"
#~ "\n"
#~ "The value is a keyword list. Two prompt types:\n"
#~ "\n"
#~ "  * `:default_prompt` - used when `Node.alive?` returns false\n"
#~ "  * `:alive_prompt`   - used when `Node.alive?` returns true\n"
#~ "\n"
#~ "The part of the listed in the following of the prompt string is "
#~ "replaced.\n"
#~ "\n"
#~ "  * `%counter` - the index of the history\n"
#~ "  * `%prefix`  - a prefix given by `IEx.Server`\n"
#~ "  * `%node`    - the name of the local node\n"
#~ "\n"
#~ msgstr ""
#~ "IExの設定をします。\n"
#~ "\n"
#~ "サポートされるオプションは: `:colors`, `:inspect`,\n"
#~ "`:default_prompt`, `:alive_prompt` そして `:history_size` です。\n"
#~ "\n"
#~ "## カラー\n"
#~ "\n"
#~ "シェルで使われる全ての色設定をカプセル化したキーワードリストです。\n"
#~ "サポートしている色と属性のリストについては`IO.ANSI`モジュールの\n"
#~ "ドキュメントを参照してください。\n"
#~ "\n"
#~ "値はキーワドリストです。サポートしているキーのリストは:\n"
#~ "\n"
#~ "  * `:enabled`      - カラーリングのオンとオフをスイッチするブール値\n"
#~ "  * `:eval_result`  - 式の結果の値のカラー\n"
#~ "  * `:eval_info`    - …様々な情報メッセージのカラー\n"
#~ "  * `:eval_error`   - …エラーメッセージのカラー\n"
#~ "  * `:stack_app`    - …スタックトレースのappの色\n"
#~ "  * `:stack_info`   - …スタックトレースの残りの情報\n"
#~ "  * `:ls_directory` - …ディレクトリエントリ (ls helper)の色\n"
#~ "  * `:ls_device`    - …デバイスエントリs (ls helper)の色\n"
#~ "\n"
#~ "ドキュメントを表示するとき、IExはmarkdownドキュメントをANSIに\n"
#~ "うまくコンバートしようとします。以下でそれらを設定できます:\n"
#~ "\n"
#~ "  * `:doc_code`        —codeブロックの属性(cyan, bright)\n"
#~ "  * `:doc_inline_code` - インライン code (cyan)\n"
#~ "  * `:doc_headings`    - h1 and h2 (yellow, bright)\n"
#~ "  * `:doc_title`       —出力の全体のヘディング (reverse,yellow,bright)\n"
#~ "  * `:doc_bold`        - (bright)\n"
#~ "  * `:doc_underline`   - (underline)\n"
#~ "\n"
#~ "## インスペクト\n"
#~ "\n"
#~ "式を評価した結果を表示するときにシェルにより使用されるインスペクトオプ\n"
#~ "ションを含んでいるキーワードリストです。プリティフォーマットのデフォル\n"
#~ "トは50エントリになっています。\n"
#~ "\n"
#~ "オプションの完全なリストは`Inspect.Opts`を参照してください。\n"
#~ "\n"
#~ "## History size\n"
#~ "\n"
#~ "ヒストリに式とその結果を保持する数です。\n"
#~ "その値は整数です。負の数のときは、ヒストリは無制限です。\n"
#~ "\n"
#~ "## プロンプト\n"
#~ "\n"
#~ "入力を待つときにユーザに表示するプロンプトを決定するオプションです。\n"
#~ "値はキーワードリストです。二つのプロンプトタイプがあります:\n"
#~ "\n"
#~ "  * `:default_prompt` - `Node.alive?` が false のとき使われます\n"
#~ "  * `:alive_prompt`   - `Node.alive?` が true のとき使われます\n"
#~ "\n"
#~ "プロンプト文字列のうち、以下にリストされた部分は置き換えられます。\n"
#~ "\n"
#~ "  * `%counter` - ヒストリのインデックス\n"
#~ "  * `%prefix`  - `IEx.Server`により与えられたプレフィックス\n"
#~ "  * `%node`    - ローカルノードの名前\n"
#~ "\n"

#~ msgid ""
#~ "Clears the console screen.\n"
#~ "\n"
#~ "This function only works if ANSI escape codes are enabled\n"
#~ "on the shell, which means this function is by default\n"
#~ "unavailable on Windows machines.\n"
#~ msgstr ""
#~ "コンソールスクリーンをクリアします。\n"
#~ "\n"
#~ "この関数はANSIエスケープコードが有効なシェルでのみ動作します。\n"
#~ "これはデフォルトではWindowsでは利用できないことを意味します。\n"

#~ msgid "Changes the current working directory to the given path.\n"
#~ msgstr "与えられたパスへカレントディレクトリを変更します。\n"

#~ msgid "Appends one entry to the history with the given counter.\n"
#~ msgstr "与えられたカウンタ値でヒストリにエントリを一つ追加します。\n"

#~ msgid ""
#~ "Documentation for the given function and arity in the list of modules.\n"
#~ msgstr ""
#~ "モジュールのリスト内で与えられた関数とアリティに対するドキュメンテーショ"
#~ "ン\n"

#~ msgid ""
#~ "Documentation for modules.\n"
#~ "It has a fallback clauses\n"
#~ msgstr ""
#~ "モジュールに対するドキュメント。\n"
#~ "フォールバック節を持ちます。\n"

#~ msgid ""
#~ "Docs for the given function, with any arity, in any of the modules.\n"
#~ msgstr ""
#~ "モジュールのリスト内で与えられた任意のアリティの関数に対するドキュメント\n"

#~ msgid "Clear the console screen.\n"
#~ msgstr "コンソールスクリーンをクリアします。\n"
