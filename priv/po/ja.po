msgid ""
msgstr ""
"Project-Id-Version: l 10n_iex\n"
"PO-Revision-Date: 2014-10-09 22:24+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: lib/l10n_iex.ex:5
msgid "OK"
msgstr "OK"

#. TRANSLATORS: def IEx.after_spawn()
#: lib/iex.ex:314
msgid "Returns registered `after_spawn` callbacks.\n"
msgstr "登録された`after_spawn`コールバックを返します。\n"

#. TRANSLATORS: def IEx.after_spawn(fun)
#: lib/iex.ex:307
msgid "Registers a function to be invoked after the IEx process is spawned.\n"
msgstr "IExプロセスが生成された後に起動される関数を登録します。\n"

#. TRANSLATORS: defmacro IEx.pry(timeout \\ 1000)
#: lib/iex.ex:422
msgid ""
"Pries into the process environment.\n"
"\n"
"This is useful for debugging a particular chunk of code\n"
"and inspect the state of a particular process. The process\n"
"is temporarily changed to trap exits (i.e. the process flag\n"
"`:trap_exit` is set to true) and has the `group_leader` changed\n"
"to support ANSI escape codes. Those values are reverted by\n"
"calling `respawn`, which starts a new IEx shell, freeing up\n"
"the pried one.\n"
"\n"
"When a process is pried, all code runs inside IEx and, as\n"
"such, it is evaluated and cannot access private functions\n"
"of the module being pried. Module functions still need to be\n"
"accessed via `Mod.fun(args)`.\n"
"\n"
"## Examples\n"
"\n"
"Let's suppose you want to investigate what is happening\n"
"with some particular function. By invoking `IEx.pry` from\n"
"the function, IEx will allow you to access its binding\n"
"(variables), verify its lexical information and access\n"
"the process information. Let's see an example:\n"
"\n"
"    import Enum, only: [map: 2]\n"
"    require IEx\n"
"\n"
"    defmodule Adder do\n"
"      def add(a, b) do\n"
"        c = a + b\n"
"        IEx.pry\n"
"      end\n"
"    end\n"
"\n"
"When invoking `Adder.add(1, 2)`, you will receive a message in\n"
"your shell to pry the given environment. By allowing it,\n"
"the shell will be reset and you gain access to all variables\n"
"and the lexical scope from above:\n"
"\n"
"    pry(1)> map([a,b,c], &IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"Keep in mind that `IEx.pry` runs in the caller process,\n"
"blocking the caller during the evaluation cycle. The caller\n"
"process can be freed by calling `respawn`, which starts a\n"
"new IEx evaluation cycle, letting this one go:\n"
"\n"
"    pry(2)> respawn\n"
"    true\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"\n"
"Setting variables or importing modules in IEx does not\n"
"affect the caller the environment (hence it is called `pry`).\n"
msgstr ""
"プロセス環境を覗き見します。\n"
"\n"
"これは特定のコードの塊のデバッグと特定のプロセスの状態を\n"
"調べるのに役に立ちます。\n"
"\n"
"プロセスは一時的に`trap exits`に変更され(即ち、プロセスフラグ\n"
"`:trap_exit`がtrueにセットされます)、`group_leader`がANSIエスケープコー\n"
"ドをサポートするために変更されます。\n"
"これらの値は`respawn`を呼ぶことで戻され、新しいIExシェルを始め、\n"
"覗き見していたものを解放します。\n"
"\n"
"プロセスが覗き見されるとき、全てのコードはIExの中で動作します。そして覗\n"
"き見しているモジュールのプライベートな関数にアクセスしたり、評価したり\n"
"出来ません。モジュール関数は、まだ`Mod.fun(args)`でアクセスされる必要が\n"
"あります。\n"
"\n"
"## 例\n"
"\n"
"若干の特定の関数に何が起っているかを調査したいと仮定します。\n"
"IEx.pryを起動することにより、IExはあなたに変数のバインディングへの\n"
"アクセスやレキシカル情報の確認、プロセス情報へのアクセスを\n"
"許可するようになります。例を見てみましょう:\n"
"\n"
"    import Enum, only: [map: 2]\n"
"    require IEx\n"
"\n"
"    defmodule Adder do\n"
"      def add(a, b) do\n"
"        c = a + b\n"
"        IEx.pry\n"
"      end\n"
"    end\n"
"\n"
"`Adder.add(1, 2)`が起動されると、あなたのシェルに与えられた環境を覗くた\n"
"めのメッセージを受信します。これをあなたが許可することで、IEx.pryが呼び\n"
"出された時点でのレキシカルスコープと全ての変数へのアクセスが出来るよう\n"
"になります。\n"
"\n"
"    pry(1)> map([a,b,c], &IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"\n"
"評価サイクルの間ブロックされている呼び出し側プロセスの`IEx.pry`は動作中\n"
"であることに注意してください、呼び出し側プロセスは新しいIEx評価サイクル\n"
"を開始させる`respawn`の呼出により解放されます。これをやってみましょう:\n"
"\n"
"    pry(2)> respawn\n"
"    true\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"\n"
"IExでの変数の設定やモジュールのインポートは呼び出し側環境へ\n"
"影響を与えません(それ故、それは`pry`(「覗き見」)と呼ばれています)。\n"

#. TRANSLATORS: def IEx.Evaluator.load_dot_iex(config, path \\ nil)
#: lib/iex/evaluator.ex:41
msgid ""
"Locates and loads an .iex.exs file from one of predefined locations.\n"
"Returns the new config.\n"
msgstr ""
"予め定義された場所の一つから .iex.exs ファイルの場所を指定してロードしま"
"す。\n"
"新しいコンフィグを返します。\n"

#. TRANSLATORS: def IEx.Helpers.r(module)
#: lib/iex/helpers.ex:278
msgid ""
"Recompiles and reloads the specified module's source file.\n"
"\n"
"Please note that all the modules defined in the same file as `module`\n"
"are recompiled and reloaded.\n"
msgstr ""
"指定されたモジュールのソースコードを再コンパイルして再ロードします。\n"
"\n"
"`module`と同じファイルで定義された全てのモジュールが再コンパイル、リロード\n"
"されることに注意してください。\n"

#. TRANSLATORS: def IEx.Remsh.expand(node)
#: lib/iex/remsh.ex:8
msgid ""
"Provides one helper function that is injected into connecting\n"
"remote nodes to properly handle autocompletion.\n"
msgstr ""
"リモートノードへ接続したときに、きちんと自動補間を取り扱うための\n"
"一つのヘルパー関数を提供します。\n"

#. TRANSLATORS: def IEx.Helpers.ls(path \\ ".")
#: lib/iex/helpers.ex:360
msgid ""
"Produces a simple list of a directory's contents.\n"
"If `path` points to a file, prints its full path.\n"
msgstr ""
"シンプルなディレクトリの内容のリストを提供します。\n"
"もし`path`がファイルを指していたら、そのフルパスを表示します。\n"

#. TRANSLATORS: def IEx.Server.start(opts, arg2)
#: lib/iex/server.ex:81
msgid ""
"Starts IEx by executing a given callback and spawning\n"
"the server only after the callback is done.\n"
"\n"
"The server responsibilities include:\n"
"\n"
"  * reading input\n"
"  * sending messages to the evaluator\n"
"  * handling takeover process of the evaluator\n"
"\n"
"If there is any takeover during the callback execution\n"
"we spawn a new server for it without waiting for its\n"
"conclusion.\n"
msgstr ""
"IExの開始時に、与えられたコールバックの実行と、コールバックが実行終了後\n"
"にのみサーバの生成をします。\n"
"\n"
"サーバは以下に責任をもちます:\n"
"\n"
"  * 入力の読み込み\n"
"  * 評価器へのメッセージ送信\n"
"  * 評価器のプロセスのテイクオーバーのハンドリング\n"
"\n"
"もしコールバック実行中にテイクオーバーがあったら、その結果を待つことな\n"
"く新しいサーバを生成します。\n"

#. TRANSLATORS: defmacro IEx.Helpers.t(module)
#: lib/iex/helpers.ex:188
msgid ""
"When given a module, prints specifications (or simply specs) for all the\n"
"types defined in it.\n"
"\n"
"When given a particular type name, prints its spec.\n"
"\n"
"## Examples\n"
"\n"
"    t(Enum)\n"
"    t(Enum.t/0)\n"
"    t(Enum.t)\n"
msgstr ""
"モジュールが与えらえると、そこで定義された全ての型の仕様(または\n"
"spec)を表示します。\n"
"\n"
"明示的に型の名前が与えられると、そのspecが表示されます。\n"
"\n"
"## 例\n"
"\n"
"    t(Enum)\n"
"    t(Enum.t/0)\n"
"    t(Enum.t)\n"

#. TRANSLATORS: Elixir.IEx.Helpers Summary
#: lib/iex/helpers.ex:1
msgid ""
"Welcome to Interactive Elixir. You are currently\n"
"seeing the documentation for the module `IEx.Helpers`\n"
"which provides many helpers to make Elixir's shell\n"
"more joyful to work with.\n"
"\n"
"This message was triggered by invoking the helper\n"
"`h()`, usually referred to as `h/0` (since it expects 0\n"
"arguments).\n"
"\n"
"There are many other helpers available:\n"
"\n"
"  * `c/2`       — compiles a file at the given path\n"
"  * `cd/1`      — changes the current directory\n"
"  * `clear/0`   — clears the screen\n"
"  * `flush/0`   — flushes all messages sent to the shell\n"
"  * `h/0`       — prints this help message\n"
"  * `h/1`       — prints help for the given module, function or macro\n"
"  * `l/1`       — loads the given module's beam code and purges the current "
"version\n"
"  * `ls/0`      — lists the contents of the current directory\n"
"  * `ls/1`      — lists the contents of the specified directory\n"
"  * `pwd/0`     — prints the current working directory\n"
"  * `r/1`       — recompiles and reloads the given module's source file\n"
"  * `respawn/0` — respawns the current shell\n"
"  * `s/1`       — prints spec information\n"
"  * `t/1`       — prints type information\n"
"  * `v/0`       — prints the history of commands evaluated in the session\n"
"  * `v/1`       — retrieves the nth value from the history\n"
"  * `import_file/1`\n"
"                — evaluates the given file in the shell's context\n"
"\n"
"Help for functions in this module can be consulted\n"
"directly from the command line, as an example, try:\n"
"\n"
"    h(c/2)\n"
"\n"
"You can also retrieve the documentation for any module\n"
"or function. Try these:\n"
"\n"
"    h(Enum)\n"
"    h(Enum.reverse/1)\n"
"    \n"
"To discover all available functions for a module, type the module name\n"
"follow by a dot, then press tab to trigger autocomplete. For example:\n"
"\n"
"    Enum.\n"
"\n"
"To learn more about IEx as a whole, just type `h(IEx)`.\n"
msgstr ""
"インタラクティブElixirへようこそ。あなたは現在Elixirシェルをもっと楽し\n"
"くするために提供された沢山のヘルパーモジュールである`IEx.Helpers`モジュー\n"
"ルのドキュメントを参照しています。\n"
"\n"
"このメッセージは通常`h/0`(これは引数の数が0個ということを示しています)\n"
"として参照されるヘルパー`h()`により起動され、表示されています。\n"
"\n"
"他に沢山のヘルパーが有効です:\n"
"\n"
"  * `c/2`       — 与えられたパスのファイルをコンパイルします\n"
"  * `cd/1`      — カレントディレクトリを変更します\n"
"  * `clear/0`   — スクリーンをクリアします\n"
"  * `flush/0`   — シェルへ送信した全メッセージを破棄します\n"
"  * `h/0`       — このヘルプメッセージを表示します\n"
"  * `h/1`       — 与えられたモジュール、関数、マクロのヘルプを表示します\n"
"  * `l/1`       — beamコードをロードして現在のバージョンをパージします\n"
"  * `ls/0`      — カレントディレクトリの内容をリストします\n"
"  * `ls/1`      — 指定されたディレクトリの内容をリストします\n"
"  * `pwd/0`     — カレントワーキングディレクトリを表示します\n"
"  * `r/1`       — 与えられたモジュールのソースコードを再コンパイルしてリロードします\n"
"  * `respawn/0` — 現在のシェルを再生成します\n"
"  * `s/1`       — Spec情報を表示します\n"
"  * `t/1`       — 型情報を表示します\n"
"  * `v/0`       — セッションのコマンド評価の履歴を表示します\n"
"  * `v/1`       — 履歴のn番目を取り出します\n"
"  * `import_file/1`\n"
"                — シェルのコンテキストで与えられたファイルを評価します\n"
"\n"
"このモジュールの関数のヘルプはコマンドラインから\n"
"このようにして、直接調べることができる。やってみよう:\n"
"\n"
"    h(c/2)\n"
"\n"
"任意のモジュールあるいは関数のドキュメントも取り出すことがきる。このよ\n"
"うにしてみよう:\n"
"\n"
"    h(Enum)\n"
"    h(Enum.reverse/1)\n"
"\n"
"モジュールで全ての有効な関数を見付けるためには、モジュール名の後ろで\n"
"ドットをタイプして、それからタブを押すことで、オートコンプリートが\n"
"起動されます。例えば:\n"
"\n"
"    Enum.\n"
"\n"
"IEx全体についてもっと学ぶためには、`h(IEx)`とタイプしよう。\n"

#. TRANSLATORS: defmacro IEx.Helpers.s(other)
#: lib/iex/helpers.ex:222
msgid ""
"Similar to `t/1`, only for specs.\n"
"\n"
"When given a module, prints the list of all specs defined in the module.\n"
"\n"
"When given a particular spec name (with optional arity), prints its spec.\n"
"\n"
"## Examples\n"
"\n"
"    s(Enum)\n"
"    s(Enum.all?)\n"
"    s(Enum.all?/2)\n"
"    s(is_atom)\n"
"    s(is_atom/1)\n"
"\n"
msgstr ""
"`t/1`と似ていますが、spec用です。\n"
"\n"
"モジュールを与えるとモジュールで定義された全てのspecのリストを表示します。\n"
"\n"
"明示的にspec名を指定すると(アリティはオプションです)、そのspecを表示しま"
"す。\n"
"\n"
"## 例\n"
"\n"
"    s(Enum)\n"
"    s(Enum.all?)\n"
"    s(Enum.all?/2)\n"
"    s(is_atom)\n"
"    s(is_atom/1)\n"
"\n"

#. TRANSLATORS: def IEx.started?()
#: lib/iex.ex:322
msgid "Returns `true` if IEx was started.\n"
msgstr "もしIExが開始されていたら`true`を返します。\n"

#. TRANSLATORS: def IEx.color(color, string)
#: lib/iex.ex:331
msgid ""
"Returns `string` escaped using the specified `color`.\n"
"\n"
"ANSI escapes in `string` are not processed in any way.\n"
msgstr ""
"指定された`color`を使ってエスケープされた`string`を返します。\n"
"\n"
"`string`の中のANSIエスケープはどのようにも処理されません。\n"
"(`color`はColorsでリストされているスタイルを表すアトムです)\n"

#. TRANSLATORS: def IEx.configuration()
#: lib/iex.ex:300
msgid "Returns IEx configuration.\n"
msgstr "IEx設定を返します。\n"

#. TRANSLATORS: def IEx.Helpers.v(n)
#: lib/iex/helpers.ex:268
msgid ""
"Retrieves the nth expression's value from the history.\n"
"\n"
"Use negative values to lookup expression values relative to the current "
"one.\n"
"For instance, v(-1) returns the result of the last evaluated expression.\n"
msgstr ""
"ヒストリからn番目の式を取り出します。\n"
"\n"
"現在の地点からの相対的に指定するためには負の値を使ってください。\n"
"例えば、v(-1)は最後に評価された式を返します。\n"

#. TRANSLATORS: def IEx.Helpers.respawn()
#: lib/iex/helpers.ex:424
msgid ""
"Respawns the current shell by starting a new\n"
"process and a new scope. Returns true if it worked.\n"
msgstr ""
"新しいスコープとプロセスを開始することで現在のシェルを再生成します。\n"
"成功するとtrueを返します。\n"

#. TRANSLATORS: def IEx.History.reset()
#: lib/iex/history.ex:49
msgid ""
"Removes all entries from the history and forces a garbage collection cycle.\n"
msgstr ""
"ヒストリから全てのエントリを削除して、ガベージコレクションサイクルを\n"
"強制します。\n"

#. TRANSLATORS: def IEx.Server.take_over(identifier, opts, timeout \\ 1000, server \\ whereis())
#: lib/iex/server.ex:40
msgid ""
"Requests to take over the given shell from the\n"
"current process.\n"
msgstr "現在のプロセスから与えられたシェルへのテイクオーバーを要求します。\n"

#. TRANSLATORS: def IEx.Helpers.v()
#: lib/iex/helpers.ex:252
msgid ""
"Prints the history of expressions evaluated during the session along with\n"
"their results.\n"
msgstr "セッションの間に評価された式の履歴をその結果とともに表示します。\n"

#. TRANSLATORS: defmacro IEx.Helpers.h(other)
#: lib/iex/helpers.ex:140
msgid ""
"Prints the documentation for the given module\n"
"or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    h(Enum)\n"
"    #=> Prints documentation for Enum\n"
"\n"
"It also accepts functions in the format `fun/arity`\n"
"and `module.fun/arity`, for example:\n"
"\n"
"    h receive/1\n"
"    h Enum.all?/2\n"
"    h Enum.all?\n"
"\n"
msgstr ""
"与えられたモジュールまたは関数/アリティペアのドキュメントを\n"
"表示します。\n"
"\n"
"## 例\n"
"\n"
"    h(Enum)\n"
"    #=> Prints documentation for Enum\n"
"\n"
"関数の書式としては、`fun/arity`または`module.fun/arity`の何れのフォーマッ\n"
"トも受け入れます。\n"
"例えば: \n"
"\n"
"    h receive/1\n"
"    h Enum.all?/2\n"
"    h Enum.all?\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.h()
#: lib/iex/helpers.ex:116
msgid "Prints the documentation for `IEx.Helpers`.\n"
msgstr "`IEx.Helpers`のドキュメントを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.pwd()
#: lib/iex/helpers.ex:341
msgid "Prints the current working directory.\n"
msgstr "現在の作業ディレクトリを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.l(module)
#: lib/iex/helpers.ex:307
msgid ""
"Load the given module's beam code (and ensures any previous\n"
"old version was properly purged before).\n"
msgstr ""
"与えられたモジュールのbeamコードをロードします(そしてその前に\n"
"以前の古いバージョンはパージされます)。\n"

#. TRANSLATORS: def IEx.History.init()
#: lib/iex/history.ex:8
msgid ""
"Initializes IEx process variables. All history\n"
"information is kept in the process dictionary.\n"
msgstr ""
"IExプロセス変数を初期化します。全てのヒストリ情報は\n"
"プロセス辞書にあり、保持されます。\n"

#. TRANSLATORS: def IEx.inspect_opts()
#: lib/iex.ex:360
msgid "Gets the options used for inspecting.\n"
msgstr "インスペクトに使うオプションを取得します。\n"

#. TRANSLATORS: def IEx.CLI.start()
#: lib/iex/cli.ex:52
msgid ""
"In order to work properly, IEx needs to be set as the\n"
"proper `-user` when starting the Erlang VM and we do so\n"
"by pointing exactly to this function.\n"
"\n"
"If possible, Elixir will start a tty (smart terminal)\n"
"which makes all control commands available in tty\n"
"available to the developer.\n"
"\n"
"In case `tty` is not available (for example, Windows),\n"
"a dumb terminal version is started instead.\n"
msgstr ""
"きちんと動くために、Erlang VMがスタートするときに\n"
"IExは適切な`-user`を設定する必要があります。\n"
"この関数で正にそれをします。\n"
"\n"
"可能であれば、Elixirは開発者がttyで利用できる\n"
"すべての制御コマンドを持つ tty(スマート端末)を起動します。\n"
"\n"
"`tty`が利用できない場合(たとえば、Windows)、ダム端末バージョンが\n"
"替わりに起動されます。\n"

#. TRANSLATORS: def IEx.History.nth(n)
#: lib/iex/history.ex:145
msgid ""
"Gets the nth item from the history.\n"
"\n"
"If `n` < 0, the count starts from the most recent item and goes back in "
"time.\n"
msgstr ""
"ヒストリからn番目の項目を取得します。\n"
"\n"
"もし`n` < 0なら、もっとも最近のアイテムから後ろ向きに数えます。\n"

#. TRANSLATORS: def IEx.Introspection.t(module)
#: lib/iex/introspection.ex:190
msgid "Print types in module.\n"
msgstr "モジュールのタイプを表示します。\n"

#. TRANSLATORS: def IEx.Introspection.t(module, type, arity)
#: lib/iex/introspection.ex:224
msgid "Print type in module with given arity.\n"
msgstr "与えられたアリティのモジュールのタイプを表示します。\n"

#. TRANSLATORS: def IEx.Introspection.t(module, type)
#: lib/iex/introspection.ex:203
msgid "Print the given type in module with any arity.\n"
msgstr "与えられたモジュールの任意のアリティのタイプを表示します。\n"

#. TRANSLATORS: def IEx.Introspection.s(module)
#: lib/iex/introspection.ex:245
msgid "Print specs for given module.\n"
msgstr "与えられたモジュールのスペックを表示します。\n"

#. TRANSLATORS: def IEx.Introspection.s(module, function)
#: lib/iex/introspection.ex:264
msgid "Print specs for given module and function.\n"
msgstr "与えられたモジュールと関数のスペックを表示します。\n"

#. TRANSLATORS: def IEx.Introspection.s(module, function, arity)
#: lib/iex/introspection.ex:285
msgid "Print spec in given module, with arity.\n"
msgstr "与えられたモジュールとアリティの関数のスペックを表示します。\n"

#. TRANSLATORS: def IEx.Server.whereis()
#: lib/iex/server.ex:14
msgid "Finds where the current IEx server is located.\n"
msgstr "現在のIExサーバが置かれた場所を見付けます。\n"

#. TRANSLATORS: def IEx.width()
#: lib/iex.ex:350
msgid ""
"Gets the IEx width for printing.\n"
"\n"
"Used by helpers and it has a maximum cap of 80 chars.\n"
msgstr ""
"IExの表示の幅を取得します\n"
"\n"
"ヘルパーにより使用され、最大80文字となります。\n"

#. TRANSLATORS: def IEx.Helpers.flush()
#: lib/iex/helpers.ex:315
msgid "Flushes all messages sent to the shell and prints them out.\n"
msgstr "シェルへ送られた全てのメッセージを破棄し、それらを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.c(files, path \\ ".")
#: lib/iex/helpers.ex:69
msgid ""
"Expects a list of files to compile and a path\n"
"to write their object code to. It returns the name\n"
"of the compiled modules.\n"
"\n"
"When compiling one file, there is no need to wrap it in a list.\n"
"\n"
"## Examples\n"
"\n"
"    c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    #=> [Foo,Bar]\n"
"\n"
"    c \"baz.ex\"\n"
"    #=> [Baz]\n"
msgstr ""
"コンパイルするファイルのリストとオブジェクトコードを\n"
"書き出すパスを指定します。コンパイルされたモジュールの名前を\n"
"返します。\n"
"\n"
"一つのファイルをコンパイルする時にリストにする必要はありません\n"
"\n"
"## 例\n"
"\n"
"    c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    #=> [Foo,Bar]\n"
"\n"
"    c \"baz.ex\"\n"
"    #=> [Baz]\n"

#. TRANSLATORS: defmacro IEx.Helpers.import_file(path)
#: lib/iex/helpers.ex:448
msgid ""
"Evaluates the contents of the file at `path` as if it were directly typed "
"into\n"
"the shell. `path` has to be a literal binary.\n"
"\n"
"A leading `~` in `path` is automatically expanded.\n"
"\n"
"## Examples\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # in the shell\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"
msgstr ""
"それが直接シェルでタイプされたかのように`path`のファイルの内容を評価しま"
"す。\n"
"`path`はリテラルバイナリでなくてはなりません。\n"
"\n"
"`path`の先頭の`~`は自動的に展開されます。\n"
"\n"
"## 例\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # in the shell\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"

#. TRANSLATORS: def IEx.Evaluator.start(server, leader)
#: lib/iex/evaluator.ex:13
msgid ""
"Eval loop for an IEx session. Its responsibilities include:\n"
"\n"
"  * loading of .iex files\n"
"  * evaluating code\n"
"  * trapping exceptions in the code being evaluated\n"
"  * keeping expression history\n"
"\n"
msgstr ""
"IExセッションの評価ループです。以下を行います:\n"
"\n"
"  * .iex ファイルのロード\n"
"  * コードの評価\n"
"  * 評価されているコードの例外をトラップすること\n"
"  * ヒストリの保持\n"
"\n"

#. TRANSLATORS: def IEx.History.each(fun)
#: lib/iex/history.ex:118
msgid ""
"Enumerates over all items in the history starting from the oldest one and\n"
"applies `fun` to each one in turn.\n"
msgstr ""
"もっとも古いものからスタートして全てのヒストリアイテムを列挙して、\n"
"それぞれに`fun`を適用します。\n"

#. TRANSLATORS: Elixir.IEx Summary
#: lib/iex.ex:1
msgid ""
"Elixir's interactive shell.\n"
"\n"
"This module is the main entry point for Interactive Elixir and\n"
"in this documentation we will talk a bit about how IEx works.\n"
"\n"
"Notice that some of the functionality described here will not be available\n"
"depending on your terminal. In particular, if you get a message\n"
"saying that the smart terminal could not be run, some of the\n"
"features described here won't work.\n"
"\n"
"## Helpers\n"
"\n"
"IEx provides a bunch of helpers. They can be accessed by typing\n"
"`h()` into the shell or as a documentation for the `IEx.Helpers` module.\n"
"\n"
"## The Break command\n"
"\n"
"Inside IEx, hitting `Ctrl+C` will open up the `BREAK` menu. In this\n"
"menu you can quit the shell, see process and ets tables information\n"
"and much more.\n"
"\n"
"## The User Switch command\n"
"\n"
"Besides the break command, one can type `Ctrl+G` to get to the\n"
"user switch command menu. When reached, you can type `h` to\n"
"get more information.\n"
"\n"
"In this menu, developers are able to start new shells and\n"
"alternate between them. Let's give it a try:\n"
"\n"
"    User switch command\n"
"     --> s 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"The command above will start a new shell and connect to it.\n"
"Create a new variable called `hello` and assign some value to it:\n"
"\n"
"    hello = :world\n"
"\n"
"Now, let's roll back to the first shell:\n"
"\n"
"    User switch command\n"
"     --> c 1\n"
"\n"
"Now, try to access the `hello` variable again:\n"
"\n"
"    hello\n"
"    ** (UndefinedFunctionError) undefined function: hello/0\n"
"\n"
"The command above fails because we have switched shells.\n"
"Since shells are isolated from each other, you can't access the\n"
"variables defined in one shell from the other one.\n"
"\n"
"The user switch command menu also allows developers to connect to remote\n"
"shells using the `r` command. A topic which we will discuss next.\n"
"\n"
"## Remote shells\n"
"\n"
"IEx allows you to connect to another node in two fashions.\n"
"First of all, we can only connect to a shell if we give names\n"
"both to the current shell and the shell we want to connect to.\n"
"\n"
"Let's give it a try. First start a new shell:\n"
"\n"
"    $ iex --sname foo\n"
"    iex(foo@HOST)1>\n"
"\n"
"The string in between parenthesis in the prompt is the name\n"
"of your node. We can retrieve it by calling the `node()`\n"
"function:\n"
"\n"
"    iex(foo@HOST)1> node()\n"
"    :\"foo@HOST\"\n"
"    iex(foo@HOST)2> Node.alive?()\n"
"    true\n"
"\n"
"For fun, let's define a simple module in this shell too:\n"
"\n"
"    iex(foo@HOST)3> defmodule Hello do\n"
"    ...(foo@HOST)3>   def world, do: \"it works!\"\n"
"    ...(foo@HOST)3> end\n"
"\n"
"Now, let's start another shell, giving it a name as well:\n"
"\n"
"    $ iex --sname bar\n"
"    iex(bar@HOST)1>\n"
"\n"
"If we try to dispatch to `Hello.world`, it won't be available\n"
"as it was defined only in the other shell:\n"
"\n"
"    iex(bar@HOST)1> Hello.world\n"
"    ** (UndefinedFunctionError) undefined function: Hello.world/0\n"
"\n"
"However, we can connect to the other shell remotely. Open up\n"
"the User Switch prompt (Ctrl+G) and type:\n"
"\n"
"    User switch command\n"
"     --> r 'foo@HOST' 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"Now we are connected into the remote node, as the prompt shows us,\n"
"and we can access the information and modules defined over there:\n"
"\n"
"    rem(foo@macbook)1> Hello.world\n"
"    \"it works\"\n"
"\n"
"In fact, connecting to remote shells is so common that we provide\n"
"a shortcut via the command line as well:\n"
"\n"
"    $ iex --sname baz --remsh foo@HOST\n"
"\n"
"Where \"remsh\" means \"remote shell\". In general, Elixir supports:\n"
"\n"
"  * remsh from an elixir node to an elixir node\n"
"  * remsh from a plain erlang node to an elixir node (through the ^G menu)\n"
"  * remsh from an elixir node to a plain erlang node (and get an erl shell "
"there)\n"
"\n"
"Connecting an Elixir shell to a remote node without Elixir is\n"
"**not** supported.\n"
"\n"
"## The .iex.exs file\n"
"\n"
"When starting IEx, it will look for a local `.iex.exs` file (located in the "
"current\n"
"working directory), then a global one (located at `~/.iex.exs`) and will "
"load the\n"
"first one it finds (if any). The code in the chosen .iex.exs file will be\n"
"evaluated in the shell's context. So, for instance, any modules that are\n"
"loaded or variables that are bound in the .iex.exs file will be available in "
"the\n"
"shell after it has booted.\n"
"\n"
"Sample contents of a local .iex.exs file:\n"
"\n"
"    # source another `.iex.exs` file\n"
"    import_file \"~/.iex.exs\"\n"
"\n"
"    # print something before the shell starts\n"
"    IO.puts \"hello world\"\n"
"\n"
"    # bind a variable that'll be accessible in the shell\n"
"    value = 13\n"
"\n"
"Running the shell in the directory where the above .iex.exs file is located\n"
"results in:\n"
"\n"
"    $ iex\n"
"    Erlang 17 [...]\n"
"\n"
"    hello world\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> value\n"
"    13\n"
"\n"
"It is possible to load another file by supplying the `--dot-iex`\n"
"option to iex. See `iex --help`.\n"
"\n"
"## Configuring the shell\n"
"\n"
"There are a number of customization options provided by the shell. Take a "
"look\n"
"at the docs for the `IEx.configure/1` function by typing `h IEx."
"configure/1`.\n"
"\n"
"Those options can be configured in your project configuration file or "
"globally\n"
"by calling `IEx.configure/1` from your `~/.iex.exs` file like this:\n"
"\n"
"    # .iex.exs\n"
"    IEx.configure(inspect: [limit: 3])\n"
"\n"
"    ### now run the shell ###\n"
"\n"
"    $ iex\n"
"    Erlang 17 (erts-5.10.1) [...]\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> [1, 2, 3, 4, 5]\n"
"    [1,2,3,...]\n"
"\n"
"## Expressions in IEx\n"
"\n"
"As an interactive shell, IEx evaluates expressions. This has some\n"
"interesting consequences that are worth discussing.\n"
"\n"
"The first one is that the code is truly evaluated and not compiled.\n"
"This means that any benchmarking done in the shell is going to have\n"
"skewed results. So never run any profiling nor benchmarks in the shell.\n"
"\n"
"Second, IEx allows you to break an expression into many lines,\n"
"since this is common in Elixir. For example:\n"
"\n"
"    iex(1)> \"ab\n"
"    ...(1)> c\"\n"
"    \"ab\\nc\"\n"
"\n"
"In the example above, the shell will be expecting more input until it\n"
"finds the closing quote. Sometimes it is not obvious which character\n"
"the shell is expecting, and the user may find themselves trapped in\n"
"the state of incomplete expression with no ability to terminate it other\n"
"than by exiting the shell.\n"
"\n"
"For such cases, there is a special break-trigger (`#iex:break`) that when\n"
"encountered on a line by itself will force the shell to break out of any\n"
"pending expression and return to its normal state:\n"
"\n"
"    iex(1)> [\"ab\n"
"    ...(1)> c\"\n"
"    ...(1)> \"\n"
"    ...(1)> ]\n"
"    ...(1)> #iex:break\n"
"    ** (TokenMissingError) iex:1: incomplete expression\n"
"\n"
msgstr ""
"Elixirの対話シェルです。\n"
"\n"
"このモジュールはInteractive Elixirのメインエントリポイントで、そしてこ\n"
"のドキュメントにおいて、IExがどのように働くかを少し話します。\n"
"\n"
"ここで記述される機能の一部がターミナル依存のため利用できないかもしれな\n"
"いことに気を付けてください。特に、あなたがスマートターミナルが動くこと\n"
"ができなかったというメッセージを目にしたら、ここで記述される特徴のいく\n"
"つかは働きません。\n"
"\n"
"## ヘルパー\n"
"\n"
"IExはたくさんのヘルパーを提供します。それらには、シェルで`h()`とタイプ\n"
"するか、あるいは`IEx.Helpers`モジュールのドキュメンテーションとしてアク\n"
"セスすることができます。\n"
"\n"
"## ブレークコマンド\n"
"\n"
"IExの中で`Ctrl+C`を打つことは、`BREAK`メニューを開きます。このメニュー\n"
"では、シェルを止めること、プロセスとetsテーブル情報を見ること、そのほか\n"
"たくさんのことができます。\n"
"\n"
"## ユーザスイッチコマンド\n"
"\n"
"ブレークコマンドの他には、ユーザスイッチコマンドメニューを始めるために\n"
"`Ctrl+G`をタイプすることができます。 その時に、詳細な情報を得るために\n"
"`h`をタイプすることができます。\n"
"\n"
"このメニューで、開発者は新しいシェルを開始してそれらの間を\n"
"行き来することができます。それにトライしてみましょう:\n"
"\n"
"    User switch command\n"
"     --> s 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"上のコマンドは新しいシェルを開始してそれに接続しています。\n"
"`hello`という新しい変数を作成して、それに何か値を割り当てます:\n"
"\n"
"    hello = :world\n"
"\n"
"いま、最初のシェルへロールバックしましょう:\n"
"\n"
"    User switch command\n"
"     --> c 1\n"
"\n"
"いま、再び`hello`変数へアクセスしてみます:\n"
"\n"
"    hello\n"
"    ** (UndefinedFunctionError) undefined function: hello/0\n"
"\n"
"上のコマンドはシェルを切り替えたため失敗します。\n"
"シェルはそれぞれ互いに分離されているので、片方で定義された変数へ\n"
"もう片方からはアクセスすることができません。\n"
"\n"
"ユーザスイッチコマンドメニューによって開発者は`r`コマンドを用いてリモー\n"
"トシェルへの接続もできます。これは次の話題です。\n"
"\n"
"## リモートシェル\n"
"\n"
"IExは二つのやり方で他のノードへ接続できます。\n"
"まず第一に、接続したいシェルと接続元のシェルの両方に\n"
"名前を付けるときだけ、シェルに接続することができます。\n"
"\n"
"以下をトライしてみましょう。最初に新しいシェルを開始します:\n"
"\n"
"    $ iex --sname foo\n"
"    iex(foo@HOST)1>\n"
"\n"
"プロンプトの中にある括弧の間の文字列はノード名です。\n"
"`node()`関数を呼ぶことで、それを取得することができます:\n"
"\n"
"    iex(foo@HOST)1> node()\n"
"    :\"foo@HOST\"\n"
"    iex(foo@HOST)2> Node.alive?()\n"
"    true\n"
"\n"
"戯れに、このシェルでも簡単なモジュールを定義しましょう:\n"
"\n"
"    iex(foo@HOST)3> defmodule Hello do\n"
"    ...(foo@HOST)3>   def world, do: \"it works!\"\n"
"    ...(foo@HOST)3> end\n"
"\n"
"すぐに、もう一つのシェルを同様に名前をつけて開始しましょう:\n"
"\n"
"    $ iex --sname bar\n"
"    iex(bar@HOST)1>\n"
"\n"
"もし`Hello.world`を発行したら、それは他のシェルでのみ定義されているので\n"
"利用できないでしょう:\n"
"\n"
"    iex(bar@HOST)1> Hello.world\n"
"    ** (UndefinedFunctionError) undefined function: Hello.world/0\n"
"\n"
"しかしながら、他のシェルへリモート接続できます。ユーザスイッチプロンプ\n"
"ト(Ctrl+G)をオープンして、以下をタイプします:\n"
"\n"
"    User switch command\n"
"     --> r 'foo@HOST' 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"プロンプトが示すように、リモートノードに接続した今、そこで定義されたモ\n"
"ジュールと情報へアクセスすることができます:\n"
"\n"
"    rem(foo@macbook)1> Hello.world\n"
"    \"it works\"\n"
"\n"
"実際、以下のコマンドラインショートカットを提供しているように、リモート\n"
"シェルへの接続は一般的です:\n"
"\n"
"    $ iex --sname baz --remsh foo@HOST\n"
"\n"
"\"remsh\"のところは\"remote shell\"を意味します。一般に、Elixirは以下を\n"
"サポートします:\n"
"\n"
"  * elixirノードからelixirノードへのremsh\n"
"  * プレーンerlangノードから(^Gメニューを通って)elixirノードへのremsh\n"
"  * elixirノードからプレーンerlangノード(のerl シェル)へのremsh\n"
"\n"
"ElixirなしでリモートノードのElixirシェルへの接続はサポートされて「いませ"
"ん」。\n"
"\n"
"## .iex.exs ファイル\n"
"\n"
"IExを開始するとき、(カレントディレクトリにある)ローカル`.iex.exs`ファイ\n"
"ルを探し、それから(`~/.iex.exs'にある)グローバルなそれを探し、最初に見\n"
"付かったものをロードします(あればですが)。\n"
"選ばれた.iexファイルのコードはシェルのコンテキストで評価されます。\n"
"それで、たとえば、.iexファイルの中で束縛される変数やロードされたモジュール\n"
"はそれがブートしたあとのシェルで利用できます。\n"
"\n"
"ローカル.iexファイルのサンプルは:\n"
"\n"
"    # source another `.iex` file\n"
"    import_file \"~/.iex.exs\"\n"
"\n"
"    # print something before the shell starts\n"
"    IO.puts \"hello world\"\n"
"\n"
"    # bind a variable that'll be accessible in the shell\n"
"    value = 13\n"
"\n"
"上の.iexファイルがあるディレクトリでシェルを動かすと、以下のような結果に\n"
"なります:\n"
"\n"
"    $ iex\n"
"    Erlang 17 [...]\n"
"\n"
"    hello world\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> value\n"
"    13\n"
"\n"
"他のファイルをロードできるようにiexには`--dot-iex`オプションが\n"
"あります。詳しくは`iex --help`を参照してください。\n"
"\n"
"## シェルの設定\n"
"\n"
"いくつかのシェルのカスタマイズオプションが提供されています。`h\n"
"IEx.configure/1`をタイプすることによって`IEx.configure/1`関数のドキュメ\n"
"ントを見るてください。\n"
"\n"
"これらのオプションはプロジェクト設定ファイルで、あるいは`~/.iex.exs`ファ\n"
"イルからグローバルに`IEx.configure/1`をよぶことで設定することができます。\n"
"このように:\n"
"\n"
"    # .iex\n"
"    IEx.configure(inspect: [limit: 3])\n"
"\n"
"    ### now run the shell ###\n"
"\n"
"    $ iex\n"
"    Erlang 17 (erts-5.10.1) [...]\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> [1, 2, 3, 4, 5]\n"
"    [1,2,3,...]\n"
"\n"
"## IExでの表現式\n"
"\n"
"対話シェルとして、IExは式を評価します。これには議論する価値のある\n"
"面白い結果が幾つかあります。\n"
"\n"
"最初のものは、コードが本当に評価はされるが、コンパイルはされないという\n"
"ものです。これはシェルでされるどんなベンチマークも結果を歪めるだろうこ\n"
"とを意味します。だからシェルのなかではどんなプロファイリングもベンチマー\n"
"クも動かしてはいけません。\n"
"\n"
"次に、IExはElixirで一般的な複数の行に式を分けることを許します。たとえば:\n"
"\n"
"    iex(1)> \"ab\n"
"    ...(1)> c\"\n"
"    \"ab\\nc\"\n"
"\n"
"上の例では、閉じる引用符を見付けるまでシェルはより多くの入力を予想して\n"
"います。時々、シェルがどの文字を期待しているかは明らかでない、そして\n"
"ユーザは不完全な式の状態でシェルを終了する以外に方法がない窮地に陥るの\n"
"に気が付くかもしれない。\n"
"\n"
"そのような論拠で、そういう時に遭遇したら、式から何からでも抜け出して、\n"
"正常状態に戻るようシェルに強制する特別なブレイクトリガ(`#iex:break`)が\n"
"あるのです:\n"
"\n"
"    iex(1)> [\"ab\n"
"    ...(1)> c\"\n"
"    ...(1)> \"\n"
"    ...(1)> ]\n"
"    ...(1)> #iex:break\n"
"    ** (TokenMissingError) iex:1: incomplete expression\n"
"\n"

#. TRANSLATORS: def IEx.configure(options)
#: lib/iex.ex:275
msgid ""
"Configures IEx.\n"
"\n"
"The supported options are: `:colors`, `:inspect`,\n"
"`:default_prompt`, `:alive_prompt` and `:history_size`.\n"
"\n"
"## Colors\n"
"\n"
"A keyword list that encapsulates all color settings used by the\n"
"shell. See documentation for the `IO.ANSI` module for the list of\n"
"supported colors and attributes.\n"
"\n"
"The value is a keyword list. List of supported keys:\n"
"\n"
"  * `:enabled`      - boolean value that allows for switching the coloring "
"on and off\n"
"  * `:eval_result`  - color for an expression's resulting value\n"
"  * `:eval_info`    - … various informational messages\n"
"  * `:eval_error`   - … error messages\n"
"  * `:stack_app`    - … the app in stack traces\n"
"  * `:stack_info`   - … the remaining info in stacktraces\n"
"  * `:ls_directory` - … for directory entries (ls helper)\n"
"  * `:ls_device`    - … device entries (ls helper)\n"
"\n"
"When printing documentation, IEx will convert the markdown\n"
"documentation to ANSI as well. Those can be configured via:\n"
"\n"
"  * `:doc_code`        — the attributes for code blocks (cyan, bright)\n"
"  * `:doc_inline_code` - inline code (cyan)\n"
"  * `:doc_headings`    - h1 and h2 (yellow, bright)\n"
"  * `:doc_title`       — the overall heading for the output (reverse,yellow,"
"bright)\n"
"  * `:doc_bold`        - (bright)\n"
"  * `:doc_underline`   - (underline)\n"
"\n"
"## Inspect\n"
"\n"
"A keyword list containing inspect options used by the shell\n"
"when printing results of expression evaluation. Defailt to\n"
"pretty formatting with a limit of 50 entries.\n"
"\n"
"See `Inspect.Opts` for the full list of options.\n"
"\n"
"## History size\n"
"\n"
"Number of expressions and their results to keep in the history.\n"
"The value is an integer. When it is negative, the history is unlimited.\n"
"\n"
"## Prompt\n"
"\n"
"This is an option determining the prompt displayed to the user\n"
"when awaiting input.\n"
"\n"
"The value is a keyword list. Two prompt types:\n"
"\n"
"  * `:default_prompt` - used when `Node.alive?` returns false\n"
"  * `:alive_prompt`   - used when `Node.alive?` returns true\n"
"\n"
"The part of the listed in the following of the prompt string is replaced.\n"
"\n"
"  * `%counter` - the index of the history\n"
"  * `%prefix`  - a prefix given by `IEx.Server`\n"
"  * `%node`    - the name of the local node\n"
"\n"
msgstr ""
"IExの設定をします。\n"
"\n"
"サポートされるオプションは: `:colors`, `:inspect`,\n"
"`:default_prompt`, `:alive_prompt` そして `:history_size` です。\n"
"\n"
"## カラー\n"
"\n"
"シェルで使われる全ての色設定をカプセル化したキーワードリストです。\n"
"サポートしている色と属性のリストについては`IO.ANSI`モジュールの\n"
"ドキュメントを参照してください。\n"
"\n"
"値はキーワドリストです。サポートしているキーのリストは:\n"
"\n"
"  * `:enabled`      - カラーリングのオンとオフをスイッチするブール値\n"
"  * `:eval_result`  - 式の結果の値のカラー\n"
"  * `:eval_info`    - …様々な情報メッセージのカラー\n"
"  * `:eval_error`   - …エラーメッセージのカラー\n"
"  * `:stack_app`    - …スタックトレースのappの色\n"
"  * `:stack_info`   - …スタックトレースの残りの情報\n"
"  * `:ls_directory` - …ディレクトリエントリ (ls helper)の色\n"
"  * `:ls_device`    - …デバイスエントリs (ls helper)の色\n"
"\n"
"ドキュメントを表示するとき、IExはmarkdownドキュメントをANSIに\n"
"うまくコンバートしようとします。以下でそれらを設定できます:\n"
"\n"
"  * `:doc_code`        —codeブロックの属性(cyan, bright)\n"
"  * `:doc_inline_code` - インライン code (cyan)\n"
"  * `:doc_headings`    - h1 and h2 (yellow, bright)\n"
"  * `:doc_title`       —出力の全体のヘディング (reverse,yellow,bright)\n"
"  * `:doc_bold`        - (bright)\n"
"  * `:doc_underline`   - (underline)\n"
"\n"
"## インスペクト\n"
"\n"
"式を評価した結果を表示するときにシェルにより使用されるインスペクトオプ\n"
"ションを含んでいるキーワードリストです。プリティフォーマットのデフォル\n"
"トは50エントリになっています。\n"
"\n"
"オプションの完全なリストは`Inspect.Opts`を参照してください。\n"
"\n"
"## History size\n"
"\n"
"ヒストリに式とその結果を保持する数です。\n"
"その値は整数です。負の数のときは、ヒストリは無制限です。\n"
"\n"
"## プロンプト\n"
"\n"
"入力を待つときにユーザに表示するプロンプトを決定するオプションです。\n"
"値はキーワードリストです。二つのプロンプトタイプがあります:\n"
"\n"
"  * `:default_prompt` - `Node.alive?` が false のとき使われます\n"
"  * `:alive_prompt`   - `Node.alive?` が true のとき使われます\n"
"\n"
"プロンプト文字列のうち、以下にリストされた部分は置き換えられます。\n"
"\n"
"  * `%counter` - ヒストリのインデックス\n"
"  * `%prefix`  - `IEx.Server`により与えられたプレフィックス\n"
"  * `%node`    - ローカルノードの名前\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.clear()
#: lib/iex/helpers.ex:104
msgid ""
"Clears the console screen.\n"
"\n"
"This function only works if ANSI escape codes are enabled\n"
"on the shell, which means this function is by default\n"
"unavailable on Windows machines.\n"
msgstr ""
"コンソールスクリーンをクリアします。\n"
"\n"
"この関数はANSIエスケープコードが有効なシェルでのみ動作します。\n"
"これはデフォルトではWindowsでは利用できないことを意味します。\n"

#. TRANSLATORS: def IEx.Helpers.cd(directory)
#: lib/iex/helpers.ex:348
msgid "Changes the current working directory to the given path.\n"
msgstr "与えられたパスへカレントディレクトリを変更します。\n"

#. TRANSLATORS: def IEx.History.append(entry, counter, limit)
#: lib/iex/history.ex:16
msgid "Appends one entry to the history with the given counter.\n"
msgstr "与えられたカウンタ値でヒストリにエントリを一つ追加します。\n"

#. TRANSLATORS: def IEx.Introspection.h(modules, function, arity)
#: lib/iex/introspection.ex:88
msgid ""
"Documentation for the given function and arity in the list of modules.\n"
msgstr ""
"モジュールのリスト内で与えられた関数とアリティに対するドキュメンテーション\n"

#. TRANSLATORS: def IEx.Introspection.h(module)
#: lib/iex/introspection.ex:12
msgid ""
"Documentation for modules.\n"
"It has a fallback clauses\n"
msgstr ""
"モジュールに対するドキュメント。\n"
"フォールバック節を持ちます。\n"

#. TRANSLATORS: def IEx.Introspection.h(modules, function)
#: lib/iex/introspection.ex:47
msgid "Docs for the given function, with any arity, in any of the modules.\n"
msgstr ""
"モジュールのリスト内で与えられた任意のアリティの関数に対するドキュメント\n"

#~ msgid "Clear the console screen.\n"
#~ msgstr "コンソールスクリーンをクリアします。\n"
