#: lib/l10n_iex.ex:5 
msgid ""
"OK"
msgstr ""
#. TRANSLATORS: def IEx.after_spawn()
#: lib/iex.ex:314 
msgid ""
"Returns registered `after_spawn` callbacks.\n"
msgstr ""
#. TRANSLATORS: def IEx.after_spawn(fun)
#: lib/iex.ex:307 
msgid ""
"Registers a function to be invoked after the IEx process is spawned.\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.pry(timeout \\ 1000)
#: lib/iex.ex:422 
msgid ""
"Pries into the process environment.\n"
"\n"
"This is useful for debugging a particular chunk of code\n"
"and inspect the state of a particular process. The process\n"
"is temporarily changed to trap exits (i.e. the process flag\n"
"`:trap_exit` is set to true) and has the `group_leader` changed\n"
"to support ANSI escape codes. Those values are reverted by\n"
"calling `respawn`, which starts a new IEx shell, freeing up\n"
"the pried one.\n"
"\n"
"When a process is pried, all code runs inside IEx and, as\n"
"such, it is evaluated and cannot access private functions\n"
"of the module being pried. Module functions still need to be\n"
"accessed via `Mod.fun(args)`.\n"
"\n"
"## Examples\n"
"\n"
"Let's suppose you want to investigate what is happening\n"
"with some particular function. By invoking `IEx.pry` from\n"
"the function, IEx will allow you to access its binding\n"
"(variables), verify its lexical information and access\n"
"the process information. Let's see an example:\n"
"\n"
"    import Enum, only: [map: 2]\n"
"    require IEx\n"
"\n"
"    defmodule Adder do\n"
"      def add(a, b) do\n"
"        c = a + b\n"
"        IEx.pry\n"
"      end\n"
"    end\n"
"\n"
"When invoking `Adder.add(1, 2)`, you will receive a message in\n"
"your shell to pry the given environment. By allowing it,\n"
"the shell will be reset and you gain access to all variables\n"
"and the lexical scope from above:\n"
"\n"
"    pry(1)> map([a,b,c], &IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"Keep in mind that `IEx.pry` runs in the caller process,\n"
"blocking the caller during the evaluation cycle. The caller\n"
"process can be freed by calling `respawn`, which starts a\n"
"new IEx evaluation cycle, letting this one go:\n"
"\n"
"    pry(2)> respawn\n"
"    true\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"\n"
"Setting variables or importing modules in IEx does not\n"
"affect the caller the environment (hence it is called `pry`).\n"
msgstr ""
#. TRANSLATORS: def IEx.Evaluator.load_dot_iex(config, path \\ nil)
#: lib/iex/evaluator.ex:41 
msgid ""
"Locates and loads an .iex.exs file from one of predefined locations.\n"
"Returns the new config.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.r(module)
#: lib/iex/helpers.ex:277 
msgid ""
"Recompiles and reloads the specified module's source file.\n"
"\n"
"Please note that all the modules defined in the same file as `module`\n"
"are recompiled and reloaded.\n"
msgstr ""
#. TRANSLATORS: def IEx.Remsh.expand(node)
#: lib/iex/remsh.ex:8 
msgid ""
"Provides one helper function that is injected into connecting\n"
"remote nodes to properly handle autocompletion.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.ls(path \\ ".")
#: lib/iex/helpers.ex:359 
msgid ""
"Produces a simple list of a directory's contents.\n"
"If `path` points to a file, prints its full path.\n"
msgstr ""
#. TRANSLATORS: def IEx.Server.start(opts, arg2)
#: lib/iex/server.ex:81 
msgid ""
"Starts IEx by executing a given callback and spawning\n"
"the server only after the callback is done.\n"
"\n"
"The server responsibilities include:\n"
"\n"
"  * reading input\n"
"  * sending messages to the evaluator\n"
"  * handling takeover process of the evaluator\n"
"\n"
"If there is any takeover during the callback execution\n"
"we spawn a new server for it without waiting for its\n"
"conclusion.\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.t(module)
#: lib/iex/helpers.ex:187 
msgid ""
"When given a module, prints specifications (or simply specs) for all the\n"
"types defined in it.\n"
"\n"
"When given a particular type name, prints its spec.\n"
"\n"
"## Examples\n"
"\n"
"    t(Enum)\n"
"    t(Enum.t/0)\n"
"    t(Enum.t)\n"
msgstr ""
#. TRANSLATORS: Elixir.IEx.Helpers Summary
#: lib/iex/helpers.ex:1 
msgid ""
"Welcome to Interactive Elixir. You are currently\n"
"seeing the documentation for the module `IEx.Helpers`\n"
"which provides many helpers to make Elixir's shell\n"
"more joyful to work with.\n"
"\n"
"This message was triggered by invoking the helper\n"
"`h()`, usually referred to as `h/0` (since it expects 0\n"
"arguments).\n"
"\n"
"There are many other helpers available:\n"
"\n"
"  * `c/2`           — compiles a file at the given path\n"
"  * `cd/1`          — changes the current directory\n"
"  * `clear/0`       — clears the screen\n"
"  * `flush/0`       — flushes all messages sent to the shell\n"
"  * `h/0`           — prints this help message\n"
"  * `h/1`           — prints help for the given module, function or macro\n"
"  * `l/1`           — loads the given module's beam code\n"
"  * `ls/0`          — lists the contents of the current directory\n"
"  * `ls/1`          — lists the contents of the specified directory\n"
"  * `pwd/0`         — prints the current working directory\n"
"  * `r/1`           — recompiles and reloads the given module's source file\n"
"  * `respawn/0`     — respawns the current shell\n"
"  * `s/1`           — prints spec information\n"
"  * `t/1`           — prints type information\n"
"  * `v/0`           — prints the history of commands evaluated in the session\n"
"  * `v/1`           — retrieves the nth value from the history\n"
"  * `import_file/1` — evaluates the given file in the shell's context\n"
"\n"
"Help for functions in this module can be consulted\n"
"directly from the command line, as an example, try:\n"
"\n"
"    h(c/2)\n"
"\n"
"You can also retrieve the documentation for any module\n"
"or function. Try these:\n"
"\n"
"    h(Enum)\n"
"    h(Enum.reverse/1)\n"
"\n"
"To discover all available functions for a module, type the module name\n"
"followed by a dot, then press tab to trigger autocomplete. For example:\n"
"\n"
"    Enum.\n"
"\n"
"To learn more about IEx as a whole, just type `h(IEx)`.\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.s(other)
#: lib/iex/helpers.ex:221 
msgid ""
"Similar to `t/1`, only for specs.\n"
"\n"
"When given a module, prints the list of all specs defined in the module.\n"
"\n"
"When given a particular spec name (with optional arity), prints its spec.\n"
"\n"
"## Examples\n"
"\n"
"    s(Enum)\n"
"    s(Enum.all?)\n"
"    s(Enum.all?/2)\n"
"    s(is_atom)\n"
"    s(is_atom/1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.started?()
#: lib/iex.ex:322 
msgid ""
"Returns `true` if IEx was started.\n"
msgstr ""
#. TRANSLATORS: def IEx.color(color, string)
#: lib/iex.ex:331 
msgid ""
"Returns `string` escaped using the specified `color`.\n"
"\n"
"ANSI escapes in `string` are not processed in any way.\n"
msgstr ""
#. TRANSLATORS: def IEx.configuration()
#: lib/iex.ex:300 
msgid ""
"Returns IEx configuration.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.v(n)
#: lib/iex/helpers.ex:267 
msgid ""
"Retrieves the nth expression's value from the history.\n"
"\n"
"Use negative values to lookup expression values relative to the current one.\n"
"For instance, v(-1) returns the result of the last evaluated expression.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.respawn()
#: lib/iex/helpers.ex:423 
msgid ""
"Respawns the current shell by starting a new\n"
"process and a new scope. Returns true if it worked.\n"
msgstr ""
#. TRANSLATORS: def IEx.History.reset()
#: lib/iex/history.ex:49 
msgid ""
"Removes all entries from the history and forces a garbage collection cycle.\n"
msgstr ""
#. TRANSLATORS: def IEx.Server.take_over(identifier, opts, timeout \\ 1000, server \\ whereis())
#: lib/iex/server.ex:40 
msgid ""
"Requests to take over the given shell from the\n"
"current process.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.v()
#: lib/iex/helpers.ex:251 
msgid ""
"Prints the history of expressions evaluated during the session along with\n"
"their results.\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.h(other)
#: lib/iex/helpers.ex:139 
msgid ""
"Prints the documentation for the given module\n"
"or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    h(Enum)\n"
"    #=> Prints documentation for Enum\n"
"\n"
"It also accepts functions in the format `fun/arity`\n"
"and `module.fun/arity`, for example:\n"
"\n"
"    h receive/1\n"
"    h Enum.all?/2\n"
"    h Enum.all?\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.h()
#: lib/iex/helpers.ex:115 
msgid ""
"Prints the documentation for `IEx.Helpers`.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.pwd()
#: lib/iex/helpers.ex:340 
msgid ""
"Prints the current working directory.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.l(module)
#: lib/iex/helpers.ex:306 
msgid ""
"Load the given module's beam code (and ensures any previous\n"
"old version was properly purged before).\n"
msgstr ""
#. TRANSLATORS: def IEx.History.init()
#: lib/iex/history.ex:8 
msgid ""
"Initializes IEx process variables. All history\n"
"information is kept in the process dictionary.\n"
msgstr ""
#. TRANSLATORS: def IEx.inspect_opts()
#: lib/iex.ex:360 
msgid ""
"Gets the options used for inspecting.\n"
msgstr ""
#. TRANSLATORS: def IEx.CLI.start()
#: lib/iex/cli.ex:52 
msgid ""
"In order to work properly, IEx needs to be set as the\n"
"proper `-user` when starting the Erlang VM and we do so\n"
"by pointing exactly to this function.\n"
"\n"
"If possible, Elixir will start a tty (smart terminal)\n"
"which makes all control commands available in tty\n"
"available to the developer.\n"
"\n"
"In case `tty` is not available (for example, Windows),\n"
"a dumb terminal version is started instead.\n"
msgstr ""
#. TRANSLATORS: def IEx.History.nth(n)
#: lib/iex/history.ex:145 
msgid ""
"Gets the nth item from the history.\n"
"\n"
"If `n` < 0, the count starts from the most recent item and goes back in time.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.t(module)
#: lib/iex/introspection.ex:190 
msgid ""
"Print types in module.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.t(module, type, arity)
#: lib/iex/introspection.ex:224 
msgid ""
"Print type in module with given arity.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.t(module, type)
#: lib/iex/introspection.ex:203 
msgid ""
"Print the given type in module with any arity.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.s(module)
#: lib/iex/introspection.ex:245 
msgid ""
"Print specs for given module.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.s(module, function)
#: lib/iex/introspection.ex:264 
msgid ""
"Print specs for given module and function.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.s(module, function, arity)
#: lib/iex/introspection.ex:285 
msgid ""
"Print spec in given module, with arity.\n"
msgstr ""
#. TRANSLATORS: def IEx.Server.whereis()
#: lib/iex/server.ex:14 
msgid ""
"Finds where the current IEx server is located.\n"
msgstr ""
#. TRANSLATORS: def IEx.width()
#: lib/iex.ex:350 
msgid ""
"Gets the IEx width for printing.\n"
"\n"
"Used by helpers and it has a maximum cap of 80 chars.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.flush()
#: lib/iex/helpers.ex:314 
msgid ""
"Flushes all messages sent to the shell and prints them out.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.c(files, path \\ ".")
#: lib/iex/helpers.ex:68 
msgid ""
"Expects a list of files to compile and a path\n"
"to write their object code to. It returns the name\n"
"of the compiled modules.\n"
"\n"
"When compiling one file, there is no need to wrap it in a list.\n"
"\n"
"## Examples\n"
"\n"
"    c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    #=> [Foo,Bar]\n"
"\n"
"    c \"baz.ex\"\n"
"    #=> [Baz]\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.import_file(path)
#: lib/iex/helpers.ex:447 
msgid ""
"Evaluates the contents of the file at `path` as if it were directly typed into\n"
"the shell. `path` has to be a literal binary.\n"
"\n"
"A leading `~` in `path` is automatically expanded.\n"
"\n"
"## Examples\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # in the shell\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"
msgstr ""
#. TRANSLATORS: def IEx.Evaluator.start(server, leader)
#: lib/iex/evaluator.ex:13 
msgid ""
"Eval loop for an IEx session. Its responsibilities include:\n"
"\n"
"  * loading of .iex files\n"
"  * evaluating code\n"
"  * trapping exceptions in the code being evaluated\n"
"  * keeping expression history\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.History.each(fun)
#: lib/iex/history.ex:118 
msgid ""
"Enumerates over all items in the history starting from the oldest one and\n"
"applies `fun` to each one in turn.\n"
msgstr ""
#. TRANSLATORS: Elixir.IEx Summary
#: lib/iex.ex:1 
msgid ""
"Elixir's interactive shell.\n"
"\n"
"This module is the main entry point for Interactive Elixir and\n"
"in this documentation we will talk a bit about how IEx works.\n"
"\n"
"Notice that some of the functionalities described here will not be available\n"
"depending on your terminal. In particular, if you get a message\n"
"saying that the smart terminal could not be run, some of the\n"
"features described here won't work.\n"
"\n"
"## Helpers\n"
"\n"
"IEx provides a bunch of helpers. They can be accessed by typing\n"
"`h()` into the shell or as a documentation for the `IEx.Helpers` module.\n"
"\n"
"## The Break command\n"
"\n"
"Inside IEx, hitting `Ctrl+C` will open up the `BREAK` menu. In this\n"
"menu you can quit the shell, see process and ets tables information\n"
"and much more.\n"
"\n"
"## The User Switch command\n"
"\n"
"Besides the break command, one can type `Ctrl+G` to get to the\n"
"user switch command menu. When reached, you can type `h` to\n"
"get more information.\n"
"\n"
"In this menu, developers are able to start new shells and\n"
"alternate between them. Let's give it a try:\n"
"\n"
"    User switch command\n"
"     --> s 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"The command above will start a new shell and connect to it.\n"
"Create a new variable called `hello` and assign some value to it:\n"
"\n"
"    hello = :world\n"
"\n"
"Now, let's roll back to the first shell:\n"
"\n"
"    User switch command\n"
"     --> c 1\n"
"\n"
"Now, try to access the `hello` variable again:\n"
"\n"
"    hello\n"
"    ** (UndefinedFunctionError) undefined function: hello/0\n"
"\n"
"The command above fails because we have switched shells.\n"
"Since shells are isolated from each other, you can't access the\n"
"variables defined in one shell from the other one.\n"
"\n"
"The user switch command menu also allows developers to connect to remote\n"
"shells using the `r` command. A topic which we will discuss next.\n"
"\n"
"## Remote shells\n"
"\n"
"IEx allows you to connect to another node in two fashions.\n"
"First of all, we can only connect to a shell if we give names\n"
"both to the current shell and the shell we want to connect to.\n"
"\n"
"Let's give it a try. First start a new shell:\n"
"\n"
"    $ iex --sname foo\n"
"    iex(foo@HOST)1>\n"
"\n"
"The string in between parenthesis in the prompt is the name\n"
"of your node. We can retrieve it by calling the `node()`\n"
"function:\n"
"\n"
"    iex(foo@HOST)1> node()\n"
"    :\"foo@HOST\"\n"
"    iex(foo@HOST)2> Node.alive?()\n"
"    true\n"
"\n"
"For fun, let's define a simple module in this shell too:\n"
"\n"
"    iex(foo@HOST)3> defmodule Hello do\n"
"    ...(foo@HOST)3>   def world, do: \"it works!\"\n"
"    ...(foo@HOST)3> end\n"
"\n"
"Now, let's start another shell, giving it a name as well:\n"
"\n"
"    $ iex --sname bar\n"
"    iex(bar@HOST)1>\n"
"\n"
"If we try to dispatch to `Hello.world`, it won't be available\n"
"as it was defined only in the other shell:\n"
"\n"
"    iex(bar@HOST)1> Hello.world\n"
"    ** (UndefinedFunctionError) undefined function: Hello.world/0\n"
"\n"
"However, we can connect to the other shell remotely. Open up\n"
"the User Switch prompt (Ctrl+G) and type:\n"
"\n"
"    User switch command\n"
"     --> r 'foo@HOST' 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"Now we are connected into the remote node, as the prompt shows us,\n"
"and we can access the information and modules defined over there:\n"
"\n"
"    rem(foo@macbook)1> Hello.world\n"
"    \"it works\"\n"
"\n"
"In fact, connecting to remote shells is so common that we provide\n"
"a shortcut via the command line as well:\n"
"\n"
"    $ iex --sname baz --remsh foo@HOST\n"
"\n"
"Where \"remsh\" means \"remote shell\". In general, Elixir supports:\n"
"\n"
"  * remsh from an elixir node to an elixir node\n"
"  * remsh from a plain erlang node to an elixir node (through the ^G menu)\n"
"  * remsh from an elixir node to a plain erlang node (and get an erl shell there)\n"
"\n"
"Connecting an Elixir shell to a remote node without Elixir is\n"
"**not** supported.\n"
"\n"
"## The .iex.exs file\n"
"\n"
"When starting IEx, it will look for a local `.iex.exs` file (located in the current\n"
"working directory), then a global one (located at `~/.iex.exs`) and will load the\n"
"first one it finds (if any). The code in the chosen .iex.exs file will be\n"
"evaluated in the shell's context. So, for instance, any modules that are\n"
"loaded or variables that are bound in the .iex.exs file will be available in the\n"
"shell after it has booted.\n"
"\n"
"Sample contents of a local .iex.exs file:\n"
"\n"
"    # source another `.iex.exs` file\n"
"    import_file \"~/.iex.exs\"\n"
"\n"
"    # print something before the shell starts\n"
"    IO.puts \"hello world\"\n"
"\n"
"    # bind a variable that'll be accessible in the shell\n"
"    value = 13\n"
"\n"
"Running the shell in the directory where the above .iex.exs file is located\n"
"results in:\n"
"\n"
"    $ iex\n"
"    Erlang 17 [...]\n"
"\n"
"    hello world\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> value\n"
"    13\n"
"\n"
"It is possible to load another file by supplying the `--dot-iex`\n"
"option to iex. See `iex --help`.\n"
"\n"
"## Configuring the shell\n"
"\n"
"There are a number of customization options provided by the shell. Take a look\n"
"at the docs for the `IEx.configure/1` function by typing `h IEx.configure/1`.\n"
"\n"
"Those options can be configured in your project configuration file or globally\n"
"by calling `IEx.configure/1` from your `~/.iex.exs` file like this:\n"
"\n"
"    # .iex.exs\n"
"    IEx.configure(inspect: [limit: 3])\n"
"\n"
"    ### now run the shell ###\n"
"\n"
"    $ iex\n"
"    Erlang 17 (erts-5.10.1) [...]\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> [1, 2, 3, 4, 5]\n"
"    [1,2,3,...]\n"
"\n"
"## Expressions in IEx\n"
"\n"
"As an interactive shell, IEx evaluates expressions. This has some\n"
"interesting consequences that are worth discussing.\n"
"\n"
"The first one is that the code is truly evaluated and not compiled.\n"
"This means that any benchmarking done in the shell is going to have\n"
"skewed results. So never run any profiling nor benchmarks in the shell.\n"
"\n"
"Second, IEx allows you to break an expression into many lines,\n"
"since this is common in Elixir. For example:\n"
"\n"
"    iex(1)> \"ab\n"
"    ...(1)> c\"\n"
"    \"ab\\nc\"\n"
"\n"
"In the example above, the shell will be expecting more input until it\n"
"finds the closing quote. Sometimes it is not obvious which character\n"
"the shell is expecting, and the user may find themselves trapped in\n"
"the state of incomplete expression with no ability to terminate it other\n"
"than by exiting the shell.\n"
"\n"
"For such cases, there is a special break-trigger (`#iex:break`) that when\n"
"encountered on a line by itself will force the shell to break out of any\n"
"pending expression and return to its normal state:\n"
"\n"
"    iex(1)> [\"ab\n"
"    ...(1)> c\"\n"
"    ...(1)> \"\n"
"    ...(1)> ]\n"
"    ...(1)> #iex:break\n"
"    ** (TokenMissingError) iex:1: incomplete expression\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.configure(options)
#: lib/iex.ex:275 
msgid ""
"Configures IEx.\n"
"\n"
"The supported options are: `:colors`, `:inspect`,\n"
"`:default_prompt`, `:alive_prompt` and `:history_size`.\n"
"\n"
"## Colors\n"
"\n"
"A keyword list that encapsulates all color settings used by the\n"
"shell. See documentation for the `IO.ANSI` module for the list of\n"
"supported colors and attributes.\n"
"\n"
"The value is a keyword list. List of supported keys:\n"
"\n"
"  * `:enabled`      - boolean value that allows for switching the coloring on and off\n"
"  * `:eval_result`  - color for an expression's resulting value\n"
"  * `:eval_info`    - … various informational messages\n"
"  * `:eval_error`   - … error messages\n"
"  * `:stack_app`    - … the app in stack traces\n"
"  * `:stack_info`   - … the remaining info in stacktraces\n"
"  * `:ls_directory` - … for directory entries (ls helper)\n"
"  * `:ls_device`    - … device entries (ls helper)\n"
"\n"
"When printing documentation, IEx will convert the markdown\n"
"documentation to ANSI as well. Those can be configured via:\n"
"\n"
"  * `:doc_code`        — the attributes for code blocks (cyan, bright)\n"
"  * `:doc_inline_code` - inline code (cyan)\n"
"  * `:doc_headings`    - h1 and h2 (yellow, bright)\n"
"  * `:doc_title`       — the overall heading for the output (reverse,yellow,bright)\n"
"  * `:doc_bold`        - (bright)\n"
"  * `:doc_underline`   - (underline)\n"
"\n"
"## Inspect\n"
"\n"
"A keyword list containing inspect options used by the shell\n"
"when printing results of expression evaluation. Default to\n"
"pretty formatting with a limit of 50 entries.\n"
"\n"
"See `Inspect.Opts` for the full list of options.\n"
"\n"
"## History size\n"
"\n"
"Number of expressions and their results to keep in the history.\n"
"The value is an integer. When it is negative, the history is unlimited.\n"
"\n"
"## Prompt\n"
"\n"
"This is an option determining the prompt displayed to the user\n"
"when awaiting input.\n"
"\n"
"The value is a keyword list. Two prompt types:\n"
"\n"
"  * `:default_prompt` - used when `Node.alive?` returns false\n"
"  * `:alive_prompt`   - used when `Node.alive?` returns true\n"
"\n"
"The part of the listed in the following of the prompt string is replaced.\n"
"\n"
"  * `%counter` - the index of the history\n"
"  * `%prefix`  - a prefix given by `IEx.Server`\n"
"  * `%node`    - the name of the local node\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.clear()
#: lib/iex/helpers.ex:103 
msgid ""
"Clears the console screen.\n"
"\n"
"This function only works if ANSI escape codes are enabled\n"
"on the shell, which means this function is by default\n"
"unavailable on Windows machines.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.cd(directory)
#: lib/iex/helpers.ex:347 
msgid ""
"Changes the current working directory to the given path.\n"
msgstr ""
#. TRANSLATORS: def IEx.History.append(entry, counter, limit)
#: lib/iex/history.ex:16 
msgid ""
"Appends one entry to the history with the given counter.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.h(modules, function, arity)
#: lib/iex/introspection.ex:88 
msgid ""
"Documentation for the given function and arity in the list of modules.\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.h(module)
#: lib/iex/introspection.ex:12 
msgid ""
"Documentation for modules.\n"
"It has a fallback clauses\n"
msgstr ""
#. TRANSLATORS: def IEx.Introspection.h(modules, function)
#: lib/iex/introspection.ex:47 
msgid ""
"Docs for the given function, with any arity, in any of the modules.\n"
msgstr ""
